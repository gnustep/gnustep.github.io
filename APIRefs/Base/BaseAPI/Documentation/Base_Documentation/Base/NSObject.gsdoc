<?xml version="1.0"?>
<!DOCTYPE gsdoc PUBLIC "-//GNUstep//DTD gsdoc 1.0.4//EN" "http://www.gnustep.org/gsdoc-1_0_4.dtd">
<gsdoc base="NSObject" stylesheeturl="gnustepStyle" up="Base">
  <head>
    <title>NSObject class reference</title>
    <author name="Andrew Kachites McCallum">
      <email address="mccallum@gnu.ai.mit.edu">
        mccallum@gnu.ai.mit.edu
      </email>
    </author>
    <date>Generated at 2024-11-07 16:52:01 -0500</date>
    <copy>1995, 1996, 1998 Free Software Foundation, Inc.</copy>
  </head>
  <body>
    <front><contents /></front>
    <chapter>
      <heading>
        Software documentation for the NSObject class
      </heading>
      <class name="NSObject" ovadd="1.0.0">
        <declared>Foundation/NSObject.h</declared>
        <conform>NSObject</conform>
        <desc>
          <p>
            <code>NSObject</code> is the root class (a root
            class is a class with no superclass) of the GNUstep
            base library class hierarchy, so all classes normally
            inherit from <code>NSObject</code>. There is an
            exception though: <code>NSProxy</code> (which is
            used for remote messaging) does not inherit from
            <code>NSObject</code>.
          </p>
          <p>
            Unless you are really sure of what you are doing,
            all your own classes should inherit (directly or
            indirectly) from <code>NSObject</code> (or in
            special cases from <code>NSProxy</code>).
            <code>NSObject</code> provides the basic common
            functionality shared by all GNUstep classes
            and objects.
          </p>
          <p>
            The essential methods which must be implemented by all
            classes for their instances to be usable within
            GNUstep are declared in a separate protocol, which
            is the <code>NSObject</code> protocol. Both
            <code>NSObject</code> and <code>NSProxy</code>
            conform to this protocol, which means all objects
            in a GNUstep application will conform to this protocol
            (btw, if you don't find a method of
            <code>NSObject</code> you are looking for in this
            documentation, make sure you also look into
            the documentation for the <code>NSObject</code>
            protocol).
          </p>
          <p>
            Theoretically, in special cases you might
            need to implement a new root class. If you do, you
            need to make sure that your root class conforms (at
            least) to the <code>NSObject</code> protocol,
            otherwise it will not interact correctly with the
            GNUstep framework. Said that, I must note that I
            have never seen a case in which a new root class is
            needed.
          </p>
          <p>
            <code>NSObject</code> is a root class, which implies
            that instance methods of <code>NSObject</code> are
            treated in a special way by the Objective-C
            runtime. This is an exception to the normal way
            messaging works with class and instance methods:
            if the Objective-C runtime can't find a class method for
            a class object, as a last resort it looks for an instance
            method of the root class with the same name, and
            executes it if it finds it. This means that
            instance methods of the root class (such as
            <code>NSObject</code>) can be performed by class
            objects which inherit from that root class ! This
            can only happen if the class doesn't have a class
            method with the same name, otherwise that method -
            of course - takes the precedence. Because of this
            exception, <code>NSObject</code> 's instance
            methods are written in such a way that they work
            both on <code>NSObject</code> 's instances and on
            class objects.
          </p>
        </desc>
        <ivariable type="Class" name="isa" validity="protected" ovadd="1.0.0">
          <desc>
            Points to instance's class. Used by runtime to
            access method implementations, etc.. Set in
            <ref type="method" id="+alloc">
              +alloc
            </ref>
            , Unlike other instance variables, which are cleared
            there.
          </desc>
        </ivariable>
        <method type="id" factory="yes" ovadd="1.0.0">
          <sel>alloc</sel>
          <desc>
            Allocates a new instance of the receiver from the
            default zone, by invoking
            <ref type="method" id="+allocWithZone:">
              +allocWithZone:
            </ref>
            with
            <code>
              <ref type="function" id="NSDefaultMallocZone">
                NSDefaultMallocZone()
              </ref>
            </code>
            as the zone argument. <br /> Returns the created
            instance.
          </desc>
        </method>
        <method type="id" factory="yes" ovadd="1.0.0">
          <sel>allocWithZone:</sel>
          <arg type="NSZone*">z</arg>
          <desc>
            This is the basic method to create a new instance. It
            allocates a new instance of the receiver from the
            specified memory zone.
            <p>
              Memory for an instance of the receiver is
              allocated; a pointer to this newly created
              instance is returned. All instance variables are
              set to 0. No initialization of the instance is
              performed apart from setup to be an instance of
              the correct class: it is your responsibility to
              initialize the instance by calling an
              appropriate <code>init</code> method. If you
              are not using ARC, it is also your responsibility to
              make sure the returned instance is destroyed when
              you finish using it, by calling the
              <code>release</code> method to destroy the
              instance directly, or by using
              <code>autorelease</code> and autorelease pools.
            </p>
            <p>
              You do not normally need to override this method in
              subclasses, unless you are implementing a
              class which for some reasons silently allocates
              instances of another class (this is typically
              needed to implement class clusters and similar
              design schemes).
            </p>
            <p>
              If you have turned on debugging of object allocation
              (by calling the <code>GSDebugAllocationActive</code>
              function), this method will also update the
              various debugging counts and monitors of
              allocated objects, which you can access using
              the <code>GSDebugAllocation...</code> functions.
            </p>
          </desc>
        </method>
        <method type="Class" factory="yes" ovadd="1.0.0">
          <sel>class</sel>
          <desc>
            Returns the receiver.
          </desc>
        </method>
        <method type="void" factory="yes" ovadd="1.0.0">
          <sel>initialize</sel>
          <desc>
            This message is automatically sent to a class by the
            runtime. It is sent once for each class, just
            before the class is used for the first time
            (excluding any automatic call to
            <ref type="method" id="+load">
              +load
            </ref>
            by the runtime). <br /> The message is sent in a
            thread-safe manner... other threads may not
            call methods of the class until
            <ref type="method" id="+initialize">
              +initialize
            </ref>
            has finished executing. <br /> If the class has a
            superclass, its implementation of
            <ref type="method" id="+initialize">
              +initialize
            </ref>
            is called first. <br /> If the class does not implement
            <ref type="method" id="+initialize">
              +initialize
            </ref>
            then the implementation in the closest superclass may
            be called. This means that
            <ref type="method" id="+initialize">
              +initialize
            </ref>
            may be called more than once, and the recommended way
            to handle this by using the
            <code>if (self == [classname class])</code>
            conditional to check whether the method is
            being called for a subclass. <br /> You should never
            call
            <ref type="method" id="+initialize">
              +initialize
            </ref>
            yourself... let the runtime do it. <br /> You can
            implement
            <ref type="method" id="+initialize">
              +initialize
            </ref>
            in your own class if you need to. NSObject's
            implementation handles essential root object
            and base library initialization. <br /> It should be
            safe to call [super initialize] in your implementation
            of <ref type="method" id="+initialize">+initialize</ref>
            .
          </desc>
        </method>
        <method type="IMP" factory="yes" ovadd="1.0.0">
          <sel>instanceMethodForSelector:</sel>
          <arg type="SEL">aSelector</arg>
          <desc>
            Returns a pointer to the C function implementing
            the method used to respond to messages with
            <var>aSelector</var> by instances of the receiving
            class. <br /> Raises NSInvalidArgumentException if
            given a null selector.
          </desc>
        </method>
        <method type="NSMethodSignature*" factory="yes" ovadd="1.0.0">
          <sel>instanceMethodSignatureForSelector:</sel>
          <arg type="SEL">aSelector</arg>
          <desc>
            Returns a pointer to the C function implementing
            the method used to respond to messages with
            <var>aSelector</var> which are sent to instances of
            the receiving class. <br /> Raises
            NSInvalidArgumentException if
            given a null selector.
          </desc>
        </method>
        <method type="BOOL" factory="yes" ovadd="1.0.0">
          <sel>instancesRespondToSelector:</sel>
          <arg type="SEL">aSelector</arg>
          <desc>
            Returns a flag to say if instances of the receiver
            class will respond to the specified selector. This
            ignores situations where a subclass implements
            <ref type="method" id="-forwardInvocation:">
              -forwardInvocation:
            </ref>
            to respond to selectors not normally handled... in these
            cases the subclass may override this method to handle
            it. <br /> If given a null selector, raises
            NSInvalidArgumentException when
            in MacOS-X compatibility more, or returns
            <code>NO</code> otherwise.
          </desc>
        </method>
        <method type="BOOL" factory="yes" ovadd="1.0.0">
          <sel>isSubclassOfClass:</sel>
          <arg type="Class">aClass</arg>
          <desc>
            Returns <code>YES</code> if the receiver is
            <var>aClass</var> or a subclass of <var>aClass</var>.
          </desc>
        </method>
        <method type="void" factory="yes" ovadd="1.0.0">
          <sel>load</sel>
          <desc>
            This method is automatically invoked on any class
            which implements it when the class is loaded into the
            runtime. <br /> It is also invoked on any category
            where the method is implemented when that category is
            loaded into the runtime. <br /> The
            <ref type="method" id="+load">
              +load
            </ref>
            method is called directly by the runtime and you
            should never send a
            <ref type="method" id="+load">
              +load
            </ref>
            message to a class yourself. <br /> This method is
            called <em>before</em> the
            <ref type="method" id="+initialize">
              +initialize
            </ref>
            message is sent to the class, so you cannot depend
            on class initialisation having been performed, or upon
            other classes existing (apart from superclasses of
            the receiver, since
            <ref type="method" id="+load">
              +load
            </ref>
            is called on superclasses before it is called on their
            subclasses). <br /> As a gross generalisation,
            it is safe to use C code, including most ObjectiveC
            runtime functions within
            <ref type="method" id="+load">
              +load
            </ref>
            , but attempting to send messages to ObjectiveC objects
            is likely to fail. <br /> In GNUstep, this method is
            implemented for NSObject to perform some
            initialisation for the base library. <br />
            If you implement
            <ref type="method" id="+load">
              +load
            </ref>
            for a class, don't call [super load] in your
            implementation.
          </desc>
        </method>
        <method type="id" factory="yes" ovadd="1.0.0">
          <sel>new</sel>
          <desc>
            <p>
              This method is a short-hand for alloc followed by
              init, that is,
            </p>
            <p>
              <code>NSObject *object = [NSObject new];</code>
            </p>
            is exactly the same as
            <p>
              <code>
                NSObject *object = [[NSObject alloc] init];
              </code>
            </p>
            <p>
              This is a general convention: all
              <code>new...</code> methods are supposed to return
              a newly allocated and initialized instance, as would be
              generated by an <code>alloc</code> method
              followed by a corresponding <code>init...</code>
              method. Please note that if you are not using
              ARC, this means that instances generated by the
              <code>new...</code> methods are not autoreleased,
              that is, you are responsible for releasing
              (autoreleasing) the instances yourself.
              So when you use <code>new</code> you typically do
              something like:
            </p>
            <p>
              <code>
                NSMutableArray *array = AUTORELEASE
                ([NSMutableArray new]);
              </code>
            </p>
            <p>
              You do not normally need to override <code>new</code>
              in subclasses, because if you override
              <code>init</code> (and optionally
              <code>allocWithZone:</code> if you really need),
              <code>new</code> will automatically use your
              subclass methods.
            </p>
            <p>
              You might need instead to define new
              <code>new...</code> methods specific to your
              subclass to match any <code>init...</code>
              specific to your subclass. For example, if your
              subclass defines an instance method
            </p>
            <p>
              <code>initWithName:</code>
            </p>
            <p>
              it might be handy for you to have a class method
            </p>
            <p>
              <code>newWithName:</code>
            </p>
            <p>
              which combines <code>alloc</code> and
              <code>initWithName:</code>. You would implement it
              as follows:
            </p>
            <p>
              <code>
                + (<strong>id</strong>) newWithName: (NSString
                *)aName {return [[self alloc] initWithName:
                aName];}
              </code>
            </p>
          </desc>
        </method>
        <method type="void" factory="yes" ovadd="1.0.0">
          <sel>poseAsClass:</sel>
          <arg type="Class">aClassObject</arg>
          <desc>
            Sets up the ObjC runtime so that the receiver is used
            wherever code calls for <var>aClassObject</var> to
            be used.
          </desc>
        </method>
        <method type="BOOL" factory="yes" ovadd="10.5.0">
          <sel>resolveClassMethod:</sel>
          <arg type="SEL">name</arg>
          <desc>
            This method will be called when attempting to send a
            message a class that does not understand it. The
            class may install a new method for the given selector
            and return <code>YES</code>, otherwise it should return
            <code>NO</code>. Note: This method is only reliable
            when using the GNUstep runtime. If you require
            compatibility with the GCC runtime, you must
            also implement
            <ref type="method" id="-forwardInvocation:">
              -forwardInvocation:
            </ref>
            with equivalent semantics. This will be considerably
            slower, but more portable.
          </desc>
        </method>
        <method type="BOOL" factory="yes" ovadd="10.5.0">
          <sel>resolveInstanceMethod:</sel>
          <arg type="SEL">name</arg>
          <desc>
            This method will be called when attempting to send a
            message an instance that does not understand it.
            The class may install a new method for the given
            selector and return <code>YES</code>, otherwise it
            should return <code>NO</code>. Note: This method is
            only reliable when using the GNUstep runtime. If you
            require compatibility with the GCC runtime, you
            must also implement
            <ref type="method" id="-forwardInvocation:">
              -forwardInvocation:
            </ref>
            with equivalent semantics. This will be considerably
            slower, but more portable.
          </desc>
        </method>
        <method type="void" factory="yes" ovadd="1.0.0">
          <sel>setVersion:</sel>
          <arg type="NSInteger">aVersion</arg>
          <desc>
            Sets the version number of the receiving class. Should
            be nonnegative.
          </desc>
        </method>
        <method type="NSInteger" factory="yes" ovadd="1.0.0">
          <sel>version</sel>
          <desc>
            Returns the version number of the receiving class.
            This will default to a number assigned by the
            Objective C compiler if [NSObject -setVersion]
            has not been called.
          </desc>
        </method>
        <method type="id" ovadd="10.6.0">
          <sel>autoContentAccessingProxy</sel>
          <desc>
            Returns an auto-accessing proxy for the given
            object. This proxy sends a
            <ref type="method" id="-beginContentAccess">
              -beginContentAccess
            </ref>
            message to the receiver when it is created and an
            <ref type="method" id="-endContentAccess">
              -endContentAccess
            </ref>
            message when it is destroyed. This prevents an
            object that implements the NSDiscardableContent
            protocol from having its contents discarded for as
            <strong>long</strong> as the proxy exists. On
            systems using the GNUstep runtime, messages send to
            the proxy will be slightly slower than direct messages.
            With the GCC runtime, they will be approximately two
            orders of magnitude slower. The GNUstep runtime,
            therefore, is strongly recommended for code
            calling this method.
          </desc>
        </method>
        <method type="id" ovadd="1.0.0">
          <sel>awakeAfterUsingCoder:</sel>
          <arg type="NSCoder*">aDecoder</arg>
          <desc>
            Called after the receiver has been created by
            decoding some sort of archive. Returns self.
            Subclasses may override this to perform some
            special initialisation upon being decoded.
          </desc>
        </method>
        <method type="Class" ovadd="1.0.0">
          <sel>classForArchiver</sel>
          <desc>
            Override to substitute class when an instance is
            being archived by an
            <ref type="class" id="NSArchiver">NSArchiver</ref>
              . Default implementation returns
              <ref type="method" id="-classForCoder">
                -classForCoder
              </ref>
              .
          </desc>
        </method>
        <method type="Class" ovadd="1.0.0">
          <sel>classForCoder</sel>
          <desc>
            Override to substitute class when an instance is
            being serialized by an
            <ref type="class" id="NSCoder">NSCoder</ref>
              . Default implementation returns
              <code>[self class]</code> (no substitution).
          </desc>
        </method>
        <method type="NSString*" ovadd="10.0.0">
          <sel>className</sel>
          <desc>
            Returns the name of the class of the receiving
            object by using the
            <ref type="function" id="NSStringFromClass">
              NSStringFromClass()
            </ref>
            function. <br /> This is a MacOS-X addition for
            apple scripting, which is also generally useful.
          </desc>
        </method>
        <method type="id" ovadd="1.0.0">
          <sel>copy</sel>
          <desc>
            Creates and returns a copy of the receiver by
            calling
            <ref type="method" id="-copyWithZone:">
              -copyWithZone:
            </ref>
            passing
            <ref type="function" id="NSDefaultMallocZone">
              NSDefaultMallocZone()
            </ref>
          </desc>
        </method>
        <method type="void" ovadd="1.0.0">
          <sel>dealloc</sel>
          <desc>
            Deallocates the receiver by calling
            <ref type="function" id="NSDeallocateObject">
              NSDeallocateObject()
            </ref>
            with self as the argument. <br />
            <p>
              You should normally call the superclass
              implementation of this method when you
              override it in a subclass, or the memory
              occupied by your object will not be released.
            </p>
            <p>
              <code>NSObject</code> 's implementation of this
              method destroys the receiver, by returning the
              memory allocated to the receiver to the system.
              After this method has been called on an instance,
              you must not refer the instance in any way, because
              it does not exist any longer. If you do, it is a bug
              and your program might even crash with a segmentation
              fault.
            </p>
            <p>
              If you have turned on the debugging facilities for
              instance allocation, <code>NSObject</code> 's
              implementation of this method will also
              update the various counts and monitors of
              allocated instances (see the
              <code>GSDebugAllocation...</code> functions for
              more info).
            </p>
            <p>
              Normally you are supposed to manage the memory
              taken by objects by using the high level interface
              provided by the <code>retain</code>,
              <code>release</code> and <code>autorelease</code>
              methods (or better by the corresponding macros
              <code>RETAIN</code>, <code>RELEASE</code> and
              <code>AUTORELEASE</code>), and by autorelease
              pools and such; whenever the release/autorelease
              mechanism determines that an object is no
              longer needed (which happens when its retain count
              reaches 0), it will call the <code>dealloc</code>
              method to actually deallocate the object. This
              means that normally, you should not need to call
              <code>dealloc</code> directly as the gnustep base
              library automatically calls it for you when the
              retain count of an object reaches 0.
            </p>
            <p>
              Because the <code>dealloc</code> method will be
              called when an instance is being destroyed, if
              instances of your subclass use objects or
              resources (as it happens for most useful
              classes), you must override
              <code>dealloc</code> in subclasses to release all
              objects and resources which are used by the
              instance, otherwise these objects and resources
              would be leaked. In the subclass implementation,
              you should first release all your subclass specific
              objects and resources, and then invoke super's
              implementation (which will do the same,
              and so on up in the class hierarchy to
              <code>NSObject</code> 's implementation, which
              finally destroys the object). Here is an example
              of the implementation of <code>dealloc</code> for a
              subclass whose instances have a single instance
              variable <code>name</code> which needs to be
              released when an instance is deallocated:
            </p>
            <p>
              <code>
                - (<strong>void</strong>) dealloc {RELEASE (name);
                [super dealloc];}
              </code>
            </p>
            <p>
              <code>dealloc</code> might contain code to release
              not only objects, but also other resources, such as
              open files, network connections, raw memory
              allocated in other ways, etc.
            </p>
            <p>
              If you have allocated the memory using a non-standard
              mechanism, you will not call the superclass
              (NSObject) implementation of the method as you
              will need to handle the deallocation specially.
              <br /> In some circumstances, an object may wish
              to prevent itself from being deallocated, it can do
              this simply be refraining from calling the
              superclass implementation.
            </p>
          </desc>
        </method>
        <method type="void" ovadd="1.0.0">
          <sel>doesNotRecognizeSelector:</sel>
          <arg type="SEL">aSelector</arg>
          <desc>
            Raises an invalid argument exception providing
            information about the receivers inability to
            handle <var>aSelector</var>.
          </desc>
        </method>
        <method type="void" ovadd="10.5.0">
          <sel>finalize</sel>
          <desc>
            On a system which performs garbage collection, you
            should implement this method to execute code when
            the receiver is collected. <br /> You must not call
            this method yourself (except when a subclass calls the
            superclass method within its own
            implementation).
          </desc>
        </method>
        <method type="void" ovadd="1.0.0">
          <sel>forwardInvocation:</sel>
          <arg type="NSInvocation*">anInvocation</arg>
          <desc>
            This method is called automatically to handle a
            message sent to the receiver for which the
            receivers class has no method. <br /> The default
            implementation calls
            <ref type="method" id="-doesNotRecognizeSelector:">
              -doesNotRecognizeSelector:
            </ref>
          </desc>
        </method>
        <method type="id" ovadd="10.6.0">
          <sel>forwardingTargetForSelector:</sel>
          <arg type="SEL">aSelector</arg>
          <desc>
            If an object does not understand a message, it may
            delegate it to another object. Returning
            <code>nil</code> indicates that forwarding should
            not take place. The default implementation of this
            returns <code>nil</code>, but care should be taken
            when subclassing NSObject subclasses and overriding
            this method that the superclass implementation is
            called if returning <code>nil</code>. Note: This
            method is only reliable when using the GNUstep
            runtime and code compiled with clang. If you
            require compatibility with GCC and the GCC runtime,
            you must also implement
            <ref type="method" id="-forwardInvocation:">
              -forwardInvocation:
            </ref>
            with equivalent semantics. This will be considerably
            slower, but more portable.
          </desc>
        </method>
        <method type="id" ovadd="1.0.0">
          <sel>init</sel>
          <desc>
            Initialises the receiver... the NSObject
            implementation simply returns self.
          </desc>
        </method>
        <method type="IMP" ovadd="1.0.0">
          <sel>methodForSelector:</sel>
          <arg type="SEL">aSelector</arg>
          <desc>
            Returns a pointer to the C function implementing
            the method used to respond to messages with
            <var>aSelector</var>. <br /> Raises
            NSInvalidArgumentException if
            given a null selector.
          </desc>
        </method>
        <method type="NSMethodSignature*" ovadd="1.0.0">
          <sel>methodSignatureForSelector:</sel>
          <arg type="SEL">aSelector</arg>
          <desc>
            Returns the method signature describing how the
            receiver would handle a message with
            <var>aSelector</var>. <br /> Returns <code>nil</code>
            if given a null selector.
          </desc>
        </method>
        <method type="id" ovadd="1.0.0">
          <sel>mutableCopy</sel>
          <desc>
            Creates and returns a mutable copy of the receiver
            by calling
            <ref type="method" id="-mutableCopyWithZone:">
              -mutableCopyWithZone:
            </ref>
            passing
            <ref type="function" id="NSDefaultMallocZone">
              NSDefaultMallocZone()
            </ref>
            .
          </desc>
        </method>
        <method type="id" ovadd="1.0.0">
          <sel>replacementObjectForArchiver:</sel>
          <arg type="NSArchiver*">anArchiver</arg>
          <desc>
            Override to substitute another object for this
            instance when being archived by given
            <ref type="class" id="NSArchiver">NSArchiver</ref>
              . Default implementation returns
              <ref type="method" id="-replacementObjectForCoder:">
                -replacementObjectForCoder:
              </ref>
              .
          </desc>
        </method>
        <method type="id" ovadd="1.0.0">
          <sel>replacementObjectForCoder:</sel>
          <arg type="NSCoder*">anEncoder</arg>
          <desc>
            Override to substitute another object for this
            instance when being serialized by given
            <ref type="class" id="NSCoder">NSCoder</ref>
              . Default implementation returns <code>self</code>.
          </desc>
        </method>
        <method type="Class" ovadd="1.0.0">
          <sel>superclass</sel>
          <desc>
            Returns the super class from which the receivers
            class was derived.
          </desc>
        </method>
      </class>
    </chapter>
    <chapter>
      <heading>
        Software documentation for the NSObject(GNUstep)
        category
      </heading>
      <category name="GNUstep" class="NSObject" ovadd="0.0.0" ovrem="0.0.0" gvadd="0.0.0" gvrem="1.17.0">
        <declared>Foundation/NSObject.h</declared>
        <desc>
          Some non-standard extensions mainly needed for backwards
          compatibility and internal utility reasons.
        </desc>
        <method type="void" factory="yes" ovadd="0.0.0" ovrem="0.0.0" gvadd="0.0.0" gvrem="1.17.0">
          <sel>enableDoubleReleaseCheck:</sel>
          <arg type="BOOL">enable</arg>
          <desc>
            Enables runtime checking of
            retain/release/autorelease
            operations. <br />
            <p>
              Whenever either
              <ref type="method" id="-autorelease">
                -autorelease
              </ref>
              or <ref type="method" id="-release">-release</ref> is
              called, the contents of any autorelease pools
              will be checked to see if there are more outstanding
              release operations than the objects retain count.
              In which case an exception is raised to say that the
              object is released too many times.
            </p>
            <p>
              <strong>Beware</strong>, since this feature
              entails examining all active autorelease pools
              every time an object is released or autoreleased,
              it can cause a massive performance degradation... it
              should only be enabled for debugging.
            </p>
            <p>
              When you are having memory allocation problems, it
              may make more sense to look at the memory allocation
              debugging functions documented in NSDebug.h, or
              use the NSZombie features.
            </p>
          </desc>
        </method>
      </category>
    </chapter>
    <chapter>
      <heading>
        Software documentation for the NSObject(NEXTSTEP)
        category
      </heading>
      <category name="NEXTSTEP" class="NSObject" ovadd="0.0.0" ovrem="0.0.0">
        <declared>Foundation/NSObject.h</declared>
        <desc>
          Methods for compatibility with the NEXTSTEP
          (pre-OpenStep) 'Object' class.
        </desc>
        <method type="id" ovadd="0.0.0" ovrem="0.0.0">
          <sel>error:</sel>
          <arg type="const char*">aString</arg>
          <vararg />
          <desc>
            Logs a message. <em>Deprecated.</em> Use
            <ref type="function" id="NSLog">
              NSLog()
            </ref>
            in new code.
          </desc>
        </method>
      </category>
    </chapter>
    <chapter>
      <heading>
        Software documentation for the
        NSObject(TimedPerformers) informal
        protocol
      </heading>
      <category name="TimedPerformers" class="NSObject" ovadd="1.0.0">
        <declared>Foundation/NSObject.h</declared>
        <desc>
          Declares some methods for sending messages to self
          after a fixed delay. (These methods <em>are</em> in
          OpenStep and OS X.)
        </desc>
        <method type="void" factory="yes" ovadd="1.0.0">
          <sel>cancelPreviousPerformRequestsWithTarget:</sel>
          <arg type="id">obj</arg>
          <desc>
            Cancels any perform operations set up for the
            specified target in the current run loop.
          </desc>
        </method>
        <method type="void" factory="yes" ovadd="1.0.0">
          <sel>cancelPreviousPerformRequestsWithTarget:</sel>
          <arg type="id">obj</arg>
          <sel>selector:</sel>
          <arg type="SEL">s</arg>
          <sel>object:</sel>
          <arg type="id">arg</arg>
          <desc>
            Cancels any perform operations set up for the
            specified target in the current loop, but only if
            the value of aSelector and argument with which the
            performs were set up match those supplied. <br />
            Matching of the argument may be either by pointer
            equality or by use of the
            <ref type="method" id="-isEqual:" class="NSObject">
              [NSObject -isEqual:]
            </ref>
            method.
          </desc>
        </method>
        <method type="void" ovadd="1.0.0">
          <sel>performSelector:</sel>
          <arg type="SEL">s</arg>
          <sel>withObject:</sel>
          <arg type="id">arg</arg>
          <sel>afterDelay:</sel>
          <arg type="NSTimeInterval">seconds</arg>
          <desc>
            Sets given message to be sent to this instance after
            given delay, in any run loop mode. See
            <ref type="class" id="NSRunLoop">NSRunLoop</ref>
              .
          </desc>
        </method>
        <method type="void" ovadd="1.0.0">
          <sel>performSelector:</sel>
          <arg type="SEL">s</arg>
          <sel>withObject:</sel>
          <arg type="id">arg</arg>
          <sel>afterDelay:</sel>
          <arg type="NSTimeInterval">seconds</arg>
          <sel>inModes:</sel>
          <arg type="NSArray*">modes</arg>
          <desc>
            Sets given message to be sent to this instance after
            given delay, in given run loop <var>modes</var>. See
            <ref type="class" id="NSRunLoop">NSRunLoop</ref>
              .
          </desc>
        </method>
      </category>
    </chapter>
    <chapter>
      <heading>
        Software documentation for the NSCoding protocol
      </heading>
      <protocol name="NSCoding" ovadd="1.0.0">
        <declared>Foundation/NSObject.h</declared>
        <desc>
          This protocol must be adopted by any class wishing to
          support saving and restoring instances to an archive,
          or copying them to remote processes via the Distributed
          Objects mechanism.
        </desc>
        <method type="void" ovadd="1.0.0">
          <sel>encodeWithCoder:</sel>
          <arg type="NSCoder*">aCoder</arg>
          <desc>
            Called when it is time for receiver to be serialized
            for writing to an archive or network connection.
            Receiver should record all of its instance
            variables using methods on <var>aCoder</var>. See
            documentation for
            <ref type="class" id="NSCoder">NSCoder</ref>
              ,
              <ref type="class" id="NSArchiver">NSArchiver</ref>
                ,
                <ref type="class" id="NSKeyedArchiver">NSKeyedArchiver</ref>
                  , and/or
                  <ref type="class" id="NSPortCoder">NSPortCoder</ref>
                    for more information.
          </desc>
        </method>
        <method type="id" ovadd="1.0.0">
          <sel>initWithCoder:</sel>
          <arg type="NSCoder*">aDecoder</arg>
          <desc>
            Called on a freshly allocated receiver when it is
            time to reconstitute from serialized bytes in an
            archive or from a network connection. Receiver
            should load all of its instance variables using
            methods on aCoder. See documentation for
            <ref type="class" id="NSCoder">NSCoder</ref>
              ,
              <ref type="class" id="NSUnarchiver">NSUnarchiver</ref>
                ,
                <ref type="class" id="NSKeyedUnarchiver">NSKeyedUnarchiver</ref>
                  , and/or
                  <ref type="class" id="NSPortCoder">NSPortCoder</ref>
                    for more information.
          </desc>
        </method>
      </protocol>
    </chapter>
    <chapter>
      <heading>
        Software documentation for the NSCopying protocol
      </heading>
      <protocol name="NSCopying" ovadd="1.0.0">
        <declared>Foundation/NSObject.h</declared>
        <desc>
          This protocol must be adopted by any class wishing to
          support copying - ie where instances of the class
          should be able to create new instances which are
          copies of the original and, where a class has mutable
          and immutable versions, where the copies are immutable.
        </desc>
        <method type="id" ovadd="1.0.0">
          <sel>copyWithZone:</sel>
          <arg type="NSZone*">zone</arg>
          <desc>
            Called by
            <ref type="method" id="-copy" class="NSObject">
              [NSObject -copy]
            </ref>
            passing
            <ref type="function" id="NSDefaultMallocZone">
              NSDefaultMallocZone()
            </ref>
            as <var>zone</var>. <br /> This method returns a copy of
            the receiver and, where the receiver is a mutable
            variant of a class which has an immutable partner
            class, the object returned is an instance of that
            immutable class. <br /> The new object is
            <em>not</em> autoreleased, and is considered to be
            'owned' by the calling code... which is therefore
            responsible for releasing it. <br /> In the
            case where the receiver is an instance of a container
            class, it is undefined whether contained objects are
            merely retained in the new copy, or are themselves
            copied, or whether some other mechanism entirely is
            used.
          </desc>
        </method>
      </protocol>
    </chapter>
    <chapter>
      <heading>
        Software documentation for the NSDiscardableContent
        protocol
      </heading>
      <protocol name="NSDiscardableContent" ovadd="10.6.0">
        <declared>Foundation/NSObject.h</declared>
        <desc>
          The NSDiscardableContent protocol is used by objects
          which encapsulate data which may be discarded if
          resource constraints are exceeded. These constraints
          are typically, but not always, related memory.
        </desc>
        <method type="BOOL" ovadd="10.6.0">
          <sel>beginContentAccess</sel>
          <desc>
            This method is called before any access to the object.
            It returns <code>YES</code> if the object's content is
            still valid. The caller must call
            <ref type="method" id="-endContentAccess">
              -endContentAccess
            </ref>
            once for every call to
            <ref type="method" id="-beginContentAccess">
              -beginContentAccess
            </ref>
            ;
          </desc>
        </method>
        <method type="void" ovadd="10.6.0">
          <sel>discardContentIfPossible</sel>
          <desc>
            Discards the contents of the object if it is not
            currently being edited.
          </desc>
        </method>
        <method type="void" ovadd="10.6.0">
          <sel>endContentAccess</sel>
          <desc>
            This method indicates that the caller has finished
            accessing the contents of the object adopting
            this protocol. Every call to
            <ref type="method" id="-beginContentAccess">
              -beginContentAccess
            </ref>
            must be be paired with a call to this method after the
            caller has finished accessing the contents.
          </desc>
        </method>
        <method type="BOOL" ovadd="10.6.0">
          <sel>isContentDiscarded</sel>
          <desc>
            Returns <code>YES</code> if the contents of the
            object have been discarded, either via a call to
            <ref type="method" id="-discardContentIfPossible">
              -discardContentIfPossible
            </ref>
            while the object is not in use, or by some
            implementation dependent mechanism.
          </desc>
        </method>
      </protocol>
    </chapter>
    <chapter>
      <heading>
        Software documentation for the NSMutableCopying
        protocol
      </heading>
      <protocol name="NSMutableCopying" ovadd="1.0.0">
        <declared>Foundation/NSObject.h</declared>
        <desc>
          This protocol must be adopted by any class wishing to
          support mutable copying - ie where instances of the
          class should be able to create mutable copies of
          themselves.
        </desc>
        <method type="id" ovadd="1.0.0">
          <sel>mutableCopyWithZone:</sel>
          <arg type="NSZone*">zone</arg>
          <desc>
            Called by
            <ref type="method" id="-mutableCopy" class="NSObject">
              [NSObject -mutableCopy]
            </ref>
            passing
            <ref type="function" id="NSDefaultMallocZone">
              NSDefaultMallocZone()
            </ref>
            as <var>zone</var>. <br /> This method returns a copy of
            the receiver and, where the receiver is an immutable
            variant of a class which has a mutable partner
            class, the object returned is an instance of that
            mutable class. The new object is <em>not</em>
            autoreleased, and is considered to be 'owned'
            by the calling code... which is therefore responsible
            for releasing it. <br /> In the case where the receiver
            is an instance of a container class, it is undefined
            whether contained objects are merely retained in
            the new copy, or are themselves copied, or whether some
            other mechanism entirely is used.
          </desc>
        </method>
      </protocol>
    </chapter>
    <chapter>
      <heading>
        Software documentation for the NSObject protocol
      </heading>
      <protocol name="NSObject" ovadd="1.0.0">
        <declared>Foundation/NSObject.h</declared>
        <desc>
          The NSObject protocol describes a minimal set of methods
          that all objects are expected to support. You should be
          able to send any of the messages listed in this protocol
          to an object, and be safe in assuming that the receiver
          can handle it.
        </desc>
        <method type="id" ovadd="1.0.0">
          <sel>autorelease</sel>
          <desc>
            Performs a deferred
            <ref type="method" id="-release">
              -release
            </ref>
            operation. The object's reference count is
            decremented at the end of the scope of the
            current autorelease pool, identified either by a
            <ref type="method" id="-drain">
              -drain
            </ref>
            message sent to the current NSAutoreleasePool
            instance, or in more recent versions of
            Objective-C by the end of an @autorelease_pool
            scope. In garbage collected mode, this method does
            nothing. In automated reference counting mode, you
            may neither implement this method nor call it directly.
          </desc>
        </method>
        <method type="Class" ovadd="1.0.0">
          <sel>class</sel>
          <desc>
            Returns the class of the receiver. If the receiver
            is a proxy, then this may return the class of the proxy
            target. Use
            <ref type="method" id="-isProxy">
              -isProxy
            </ref>
            to determine whether the receiver is a proxy. If you
            wish to find the real class of the receiver, ignoring
            proxies, then use "object_getClass()".
          </desc>
        </method>
        <method type="BOOL" ovadd="1.0.0">
          <sel>conformsToProtocol:</sel>
          <arg type="Protocol*">aProtocol</arg>
          <desc>
            Returns <code>YES</code> if the receiver conforms
            to the specified protocol.
          </desc>
        </method>
        <method type="NSString*" ovadd="1.0.0">
          <sel>description</sel>
          <desc>
            Returns the description of the object. This is used
            by the %@ format specifier in strings.
          </desc>
        </method>
        <method type="NSUInteger" ovadd="1.0.0">
          <sel>hash</sel>
          <desc>
            Returns a hash value for the object. All objects
            that are equal *MUST* return the same hash value. For
            efficient storage in sets, or as keys in
            dictionaries, different objects should return
            hashes spread evenly over the range of an integer.
            An object may not return different values from this
            method after being stored in a collection. This
            typically means that ether the hash value must be
            constant after the object's creation, or that the
            object may not be modified while stored in an
            unordered collection.
          </desc>
        </method>
        <method type="BOOL" ovadd="1.0.0">
          <sel>isEqual:</sel>
          <arg type="id">anObject</arg>
          <desc>
            Returns whether the receiver is equal to the
            argument. Defining equality is complex, so be
            careful when implementing this method. Collections
            such as NSSet depend on the behaviour of this method.
            In particular, this method must be commutative, so for
            any objects a and b: [a isEqual: b] == [b isEqual: a]
            This means that you must be very careful when
            returning <code>YES</code> if the argument is of
            another class. For example, if you define a number
            class that returns <code>YES</code> if the argument
            is a string representation of the number, then this will
            break because the string will not recognise your
            object as being equal to itself. If two objects are
            equal, then they must have the same hash value,
            however equal hash values do not imply equality.
          </desc>
        </method>
        <method type="BOOL" ovadd="1.0.0">
          <sel>isKindOfClass:</sel>
          <arg type="Class">aClass</arg>
          <desc>
            Returns <code>YES</code> if the receiver is an
            instance of the class, an instance of the
            subclass, or (in the case of proxies), an
            instance of something that can be treated as an
            instance of the class.
          </desc>
        </method>
        <method type="BOOL" ovadd="1.0.0">
          <sel>isMemberOfClass:</sel>
          <arg type="Class">aClass</arg>
          <desc>
            Returns <code>YES</code> if the receiver is an
            instance of the class or (in the case of proxies),
            an instance of something that can be treated as an
            instance of the class. Calling this method is
            rarely the correct thing to do. In most cases, a
            subclass can be substituted for a superclass, so
            you should never need to check that an object is really
            an instance of a specific class and not a subclass.
          </desc>
        </method>
        <method type="BOOL" ovadd="1.0.0">
          <sel>isProxy</sel>
          <desc>
            Returns <code>YES</code> if the receiver is a
            proxy, <code>NO</code> otherwise. The default
            implementation of this method in NSObject
            returns <code>NO</code>, while the implementation
            in NSProxy returns <code>YES</code>.
          </desc>
        </method>
        <method type="id" ovadd="1.0.0">
          <sel>performSelector:</sel>
          <arg type="SEL">aSelector</arg>
          <desc>
            Performs the specified selector. The selector must
            correspond to a method that takes no arguments.
          </desc>
        </method>
        <method type="id" ovadd="1.0.0">
          <sel>performSelector:</sel>
          <arg type="SEL">aSelector</arg>
          <sel>withObject:</sel>
          <arg type="id">anObject</arg>
          <desc>
            Performs the specified selector, with the object
            as the argument. This method does not perform any
            automatic unboxing, so the selector must
            correspond to a method that takes one object
            argument.
          </desc>
        </method>
        <method type="id" ovadd="1.0.0">
          <sel>performSelector:</sel>
          <arg type="SEL">aSelector</arg>
          <sel>withObject:</sel>
          <arg type="id">object1</arg>
          <sel>withObject:</sel>
          <arg type="id">object2</arg>
          <desc>
            Performs the specified selector, with the objects
            as the arguments. This method does not perform any
            automatic unboxing, so the selector must
            correspond to a method that takes two object
            arguments.
          </desc>
        </method>
        <method type="oneway void" ovadd="1.0.0">
          <sel>release</sel>
          <desc>
            Decrements the reference count of the object and
            destroys if it there are no remaining references.
            In garbage collected mode, this method does nothing. In
            automated reference counting mode, you may
            neither implement this method nor call it directly.
          </desc>
        </method>
        <method type="BOOL" ovadd="1.0.0">
          <sel>respondsToSelector:</sel>
          <arg type="SEL">aSelector</arg>
          <desc>
            Returns <code>YES</code> if the object can respond
            to messages with the specified selector. The default
            implementation in NSObject returns
            <code>YES</code> if the receiver has a method
            corresponding to the method, but other
            classes may return <code>YES</code> if they can
            respond to a selector using one of the various
            forwarding mechanisms.
          </desc>
        </method>
        <method type="id" ovadd="1.0.0">
          <sel>retain</sel>
          <desc>
            Increments the reference count of the object and
            returns the receiver. In garbage collected mode,
            this method does nothing. In automated reference
            counting mode, you may neither implement this
            method nor call it directly.
          </desc>
        </method>
        <method type="NSUInteger" ovadd="1.0.0">
          <sel>retainCount</sel>
          <desc>
            Returns the current retain count of an object. This
            does not include the result of any pending autorelease
            operations. Code that relies on this method
            returning a sane value is broken. For singletons,
            it may return NSUIntegerMax. Even when it is tracking a
            retain count, it will not include on-stack pointers
            in manual retain/release mode, pointers marked as
            __unsafe_unretain or __weak in ARC mode,
            or pending autorelease operations. Its value is
            therefore largely meaningless. It can
            occasionally be useful for debugging.
          </desc>
        </method>
        <method type="id" ovadd="1.0.0">
          <sel>self</sel>
          <desc>
            Returns the receiver. In a proxy, this may (but is
            not required to) return the proxied object.
          </desc>
        </method>
        <method type="Class" ovadd="1.0.0">
          <sel>superclass</sel>
          <desc>
            Returns the superclass of receiver's class. If the
            receiver is a proxy, then this may return the
            class of the proxy target. Use
            <ref type="method" id="-isProxy">
              -isProxy
            </ref>
            to determine whether the receiver is a proxy. If you
            wish to find the real superclass of the receiver's
            class, ignoring proxies, then use
            "class_getSuperclass(object_getClass())".
          </desc>
        </method>
        <method type="NSZone*" ovadd="1.0.0">
          <sel>zone</sel>
          <desc>
            Returns the zone of the object.
          </desc>
        </method>
      </protocol>
    </chapter>
    <chapter>
      <heading>
        Software documentation for the NSSecureCoding protocol
      </heading>
      <protocol name="NSSecureCoding" ovadd="1.0.0">
        <declared>Foundation/NSObject.h</declared>
        <conform>NSCoding</conform>
        <desc>
          <em>Description forthcoming.</em>
        </desc>
        <method type="BOOL" factory="yes" ovadd="1.0.0">
          <sel>supportsSecureCoding</sel>
          <desc>
            <em>Description forthcoming.</em>
          </desc>
        </method>
      </protocol>
    </chapter>
  </body>
</gsdoc>
