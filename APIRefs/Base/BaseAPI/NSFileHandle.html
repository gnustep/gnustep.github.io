<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

    <head>
    <title>NSFileHandle class reference</title>
    <style type="text/css">
    hr.method-separator { width:25%; margin-left:0; }
    </style>
  </head>
  <body>
    <a href="Base.html">Up</a>
    <br />
    <h1><a name="title$NSFileHandle">NSFileHandle class reference</a></h1>
    <h3>Authors</h3>
    <dl>
      <dt>Richard Frith-Macdonald (<a href="mailto:richard@brainstorm.co.uk"><code>richard@brainstorm.co.uk</code></a>)</dt>
      <dd>
      </dd>
    </dl>
    <p><b>Date:</b> Generated at 2024-11-07 16:52:01 -0500</p>
    <p><b>Copyright:</b> (C) 1997 Free Software Foundation, Inc.</p>

        <div>
      <hr width="50%" align="left" />
      <h3>Contents -</h3>
      <ol>
        <li>
          <a href="#001000000000">Software documentation for the NSFileHandle class</a>
        </li>
        <li>
          <a href="#002000000000">Software documentation for the NSPipe class</a>
        </li>
        <li>
          <a href="#003000000000">Software documentation for the
        NSFileHandle(GNUstepExtensions)
        category</a>
        </li>
        <li>
          <a href="#004000000000">Software documentation for the
        NSFileHandle(GNUstepTLS) category</a>
        </li>
      </ol>
      <hr width="50%" align="left" />
    </div>

          <h1><a name="001000000000">
        Software documentation for the NSFileHandle class
      </a></h1>
    <h2 class="class"><a name="class$NSFileHandle">NSFileHandle</a> : <a rel="gsdoc" href="NSObject.html#class$NSObject">NSObject</a></h2>
<svg width="180pt" height="116pt"
 viewBox="0.00 0.00 180.00 116.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 112)">
<title>class_NSFileHandle</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-112 176,-112 176,4 -4,4"/>
<!-- NSObject -->
<g id="node1" class="node">
<title>NSObject</title>
<g id="a_node1"><a xlink:href="NSObject.html#class$NSObject" xlink:title="NSObject">
<polygon fill="lightgrey" stroke="black" points="145,-108 27,-108 27,-72 145,-72 145,-108"/>
<text text-anchor="middle" x="86" y="-83.8" font-family="Times,serif" font-size="24.00" fill="blue">NSObject</text>
</a>
</g>
</g>
<!-- NSFileHandle -->
<g id="node2" class="node">
<title>NSFileHandle</title>
<polygon fill="lightgrey" stroke="black" points="172,-36 0,-36 0,0 172,0 172,-36"/>
<text text-anchor="middle" x="86" y="-11.8" font-family="Times,serif" font-size="24.00" fill="green">NSFileHandle</text>
</g>
<!-- NSObject&#45;&gt;NSFileHandle -->
<g id="edge1" class="edge">
<title>NSObject&#45;&gt;NSFileHandle</title>
<path fill="none" stroke="black" d="M86,-71.7C86,-63.98 86,-54.71 86,-46.11"/>
<polygon fill="black" stroke="black" points="89.5,-46.1 86,-36.1 82.5,-46.1 89.5,-46.1"/>
</g>
</g>
</svg>
    <blockquote class="declared">
      <dl>
        <dt><b>Declared in:</b></dt>
        <dd>Foundation/NSFileHandle.h</dd>
      </dl>
    </blockquote>
    <div class="availability">
<b>Availability:</b> OpenStep</div>
<br />
    <div class="desc">
      
          
    </p>
    <p>

            <code>NSFileHandle</code> is a class that provides a
            wrapper for accessing system files and socket
            connections. You can open connections to a
            file using class methods such as
            <a rel="gsdoc" href="#method$NSFileHandle+fileHandleForReadingAtPath$">
              +fileHandleForReadingAtPath:
            </a>

            .
              </p>
    <p>
      
          
    </p>
    <p>

            GNUstep extends the use of this class to allow you
            to create network connections (sockets), secure
            connections and also allows you to use
            compression with these files and connections
            (as <strong>long</strong> as GNUstep Base was compiled
            with the zlib library).
              </p>
    <p>
      
        
    </div>
<div class="global_method_index">
    <b>Method summary</b>
    <ul>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle(GNUstepExtensions)+fileHandleAsClientAtAddress$service$protocol$">+fileHandleAsClientAtAddress:service:protocol:</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle(GNUstepExtensions)+fileHandleAsClientInBackgroundAtAddress$service$protocol$">+fileHandleAsClientInBackgroundAtAddress:service:protocol:</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle(GNUstepExtensions)+fileHandleAsClientInBackgroundAtAddress$service$protocol$forModes$">+fileHandleAsClientInBackgroundAtAddress:service:protocol:forModes:</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle(GNUstepExtensions)+fileHandleAsServerAtAddress$service$protocol$">+fileHandleAsServerAtAddress:service:protocol:</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle(GNUstepExtensions)-readDataInBackgroundAndNotifyLength$">-readDataInBackgroundAndNotifyLength:</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle(GNUstepExtensions)-readDataInBackgroundAndNotifyLength$forModes$">-readDataInBackgroundAndNotifyLength:forModes:</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle(GNUstepExtensions)-readInProgress">-readInProgress</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle(GNUstepExtensions)-socketAddress">-socketAddress</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle(GNUstepExtensions)-socketLocalAddress">-socketLocalAddress</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle(GNUstepExtensions)-socketLocalService">-socketLocalService</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle(GNUstepExtensions)-socketProtocol">-socketProtocol</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle(GNUstepExtensions)-socketService">-socketService</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle(GNUstepExtensions)-useCompression">-useCompression</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle(GNUstepExtensions)-writeInBackgroundAndNotify$">-writeInBackgroundAndNotify:</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle(GNUstepExtensions)-writeInBackgroundAndNotify$forModes$">-writeInBackgroundAndNotify:forModes:</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle(GNUstepExtensions)-writeInProgress">-writeInProgress</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle(GNUstepTLS)+setData$forTLSFile$">+setData:forTLSFile:</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle(GNUstepTLS)+sslClass">+sslClass</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle(GNUstepTLS)-sslAccept">-sslAccept</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle(GNUstepTLS)-sslConnect">-sslConnect</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle(GNUstepTLS)-sslDisconnect">-sslDisconnect</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle(GNUstepTLS)-sslHandshakeEstablished$outgoing$">-sslHandshakeEstablished:outgoing:</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle(GNUstepTLS)-sslIssuer">-sslIssuer</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle(GNUstepTLS)-sslOwner">-sslOwner</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle(GNUstepTLS)-sslSetCertificate$privateKey$PEMpasswd$">-sslSetCertificate:privateKey:PEMpasswd:</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle(GNUstepTLS)-sslSetOptions$">-sslSetOptions:</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle+fileHandleForReadingAtPath$">+fileHandleForReadingAtPath:</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle+fileHandleForReadingFromURL$error$">+fileHandleForReadingFromURL:error:</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle+fileHandleForUpdatingAtPath$">+fileHandleForUpdatingAtPath:</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle+fileHandleForUpdatingURL$error$">+fileHandleForUpdatingURL:error:</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle+fileHandleForWritingAtPath$">+fileHandleForWritingAtPath:</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle+fileHandleForWritingToURL$error$">+fileHandleForWritingToURL:error:</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle+fileHandleWithNullDevice">+fileHandleWithNullDevice</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle+fileHandleWithStandardError">+fileHandleWithStandardError</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle+fileHandleWithStandardInput">+fileHandleWithStandardInput</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle+fileHandleWithStandardOutput">+fileHandleWithStandardOutput</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle-acceptConnectionInBackgroundAndNotify">-acceptConnectionInBackgroundAndNotify</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle-acceptConnectionInBackgroundAndNotifyForModes$">-acceptConnectionInBackgroundAndNotifyForModes:</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle-availableData">-availableData</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle-closeFile">-closeFile</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle-fileDescriptor">-fileDescriptor</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle-getOffset$error$">-getOffset:error:</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle-initWithFileDescriptor$">-initWithFileDescriptor:</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle-initWithFileDescriptor$closeOnDealloc$">-initWithFileDescriptor:closeOnDealloc:</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle-initWithNativeHandle$">-initWithNativeHandle:</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle-initWithNativeHandle$closeOnDealloc$">-initWithNativeHandle:closeOnDealloc:</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle-nativeHandle">-nativeHandle</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle-offsetInFile">-offsetInFile</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle-readDataOfLength$">-readDataOfLength:</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle-readDataToEndOfFile">-readDataToEndOfFile</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle-readInBackgroundAndNotify">-readInBackgroundAndNotify</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle-readInBackgroundAndNotifyForModes$">-readInBackgroundAndNotifyForModes:</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle-readToEndOfFileInBackgroundAndNotify">-readToEndOfFileInBackgroundAndNotify</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle-readToEndOfFileInBackgroundAndNotifyForModes$">-readToEndOfFileInBackgroundAndNotifyForModes:</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle-seekToEndOfFile">-seekToEndOfFile</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle-seekToFileOffset$">-seekToFileOffset:</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle-synchronizeFile">-synchronizeFile</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle-truncateFileAtOffset$">-truncateFileAtOffset:</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle-waitForDataInBackgroundAndNotify">-waitForDataInBackgroundAndNotify</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle-waitForDataInBackgroundAndNotifyForModes$">-waitForDataInBackgroundAndNotifyForModes:</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle-writeData$">-writeData:</a></li>
    </ul>
</div>
    <hr width="50%" align="left" />
<div class="method">
    <h3><a name="method$NSFileHandle+fileHandleForReadingAtPath$">fileHandleForReadingAtPath:&nbsp;</a></h3>
    + (instancetype) <b>fileHandleForReadingAtPath:</b> (<a rel="gsdoc" href="NSString.html#class$NSString">NSString</a>*)path;<br />
    <div class="availability">
<b>Availability:</b> OpenStep</div>
<br />
    <div class="desc">
      
            Returns an <code>NSFileHandle</code> object set up
            for reading from the file listed at <var>path</var>. If
            the file does not exist or cannot be opened for some
            other reason, <code>nil</code> is returned.
          
    </div>
    <hr class="method-separator"/>
</div>
<div class="method">
    <h3><a name="method$NSFileHandle+fileHandleForReadingFromURL$error$">fileHandleForReadingFromURL:&nbsp;error:&nbsp;</a></h3>
    + (instancetype) <b>fileHandleForReadingFromURL:</b> (<a rel="gsdoc" href="NSURL.html#class$NSURL">NSURL</a>*)url<b> error:</b> (<a rel="gsdoc" href="NSError.html#class$NSError">NSError</a>**)error;<br />
    <div class="availability">
<b>Availability:</b> MacOS-X 10.6.0</div>
<br />
    <div class="desc">
      
            <em>Description forthcoming.</em>
          
    </div>
    <hr class="method-separator"/>
</div>
<div class="method">
    <h3><a name="method$NSFileHandle+fileHandleForUpdatingAtPath$">fileHandleForUpdatingAtPath:&nbsp;</a></h3>
    + (instancetype) <b>fileHandleForUpdatingAtPath:</b> (<a rel="gsdoc" href="NSString.html#class$NSString">NSString</a>*)path;<br />
    <div class="availability">
<b>Availability:</b> OpenStep</div>
<br />
    <div class="desc">
      
            Returns an <code>NSFileHandle</code> object setup
            for updating (reading and writing) from the file listed
            at <var>path</var>. If the file does not exist or cannot
            be opened for some other reason, <code>nil</code> is
            returned.
          
    </div>
    <hr class="method-separator"/>
</div>
<div class="method">
    <h3><a name="method$NSFileHandle+fileHandleForUpdatingURL$error$">fileHandleForUpdatingURL:&nbsp;error:&nbsp;</a></h3>
    + (instancetype) <b>fileHandleForUpdatingURL:</b> (<a rel="gsdoc" href="NSURL.html#class$NSURL">NSURL</a>*)url<b> error:</b> (<a rel="gsdoc" href="NSError.html#class$NSError">NSError</a>**)error;<br />
    <div class="availability">
<b>Availability:</b> MacOS-X 10.6.0</div>
<br />
    <div class="desc">
      
            <em>Description forthcoming.</em>
          
    </div>
    <hr class="method-separator"/>
</div>
<div class="method">
    <h3><a name="method$NSFileHandle+fileHandleForWritingAtPath$">fileHandleForWritingAtPath:&nbsp;</a></h3>
    + (instancetype) <b>fileHandleForWritingAtPath:</b> (<a rel="gsdoc" href="NSString.html#class$NSString">NSString</a>*)path;<br />
    <div class="availability">
<b>Availability:</b> OpenStep</div>
<br />
    <div class="desc">
      
            Returns an <code>NSFileHandle</code> object set up
            for writing to the file listed at <var>path</var>. If
            the file does not exist or cannot be opened for some
            other reason, <code>nil</code> is returned.
          
    </div>
    <hr class="method-separator"/>
</div>
<div class="method">
    <h3><a name="method$NSFileHandle+fileHandleForWritingToURL$error$">fileHandleForWritingToURL:&nbsp;error:&nbsp;</a></h3>
    + (instancetype) <b>fileHandleForWritingToURL:</b> (<a rel="gsdoc" href="NSURL.html#class$NSURL">NSURL</a>*)url<b> error:</b> (<a rel="gsdoc" href="NSError.html#class$NSError">NSError</a>**)error;<br />
    <div class="availability">
<b>Availability:</b> MacOS-X 10.6.0</div>
<br />
    <div class="desc">
      
            <em>Description forthcoming.</em>
          
    </div>
    <hr class="method-separator"/>
</div>
<div class="method">
    <h3><a name="method$NSFileHandle+fileHandleWithNullDevice">fileHandleWithNullDevice&nbsp;</a></h3>
    + (instancetype) <b>fileHandleWithNullDevice</b>;<br />
    <div class="availability">
<b>Availability:</b> OpenStep</div>
<br />
    <div class="desc">
      
            Returns a file handle object that is connected to
            the null device (i.e. a device that does nothing.) It
            is typically used in arrays and other collections of
            file handle objects as a place holder (null) object,
            so that all objects can respond to the same messages.
          
    </div>
    <hr class="method-separator"/>
</div>
<div class="method">
    <h3><a name="method$NSFileHandle+fileHandleWithStandardError">fileHandleWithStandardError&nbsp;</a></h3>
    + (instancetype) <b>fileHandleWithStandardError</b>;<br />
    <div class="availability">
<b>Availability:</b> OpenStep</div>
<br />
    <div class="desc">
      
            Returns an <code>NSFileHandle</code> object for the
            standard error descriptor. The returned object is
            a shared instance as there can only be one standard error
            per process.
          
    </div>
    <hr class="method-separator"/>
</div>
<div class="method">
    <h3><a name="method$NSFileHandle+fileHandleWithStandardInput">fileHandleWithStandardInput&nbsp;</a></h3>
    + (instancetype) <b>fileHandleWithStandardInput</b>;<br />
    <div class="availability">
<b>Availability:</b> OpenStep</div>
<br />
    <div class="desc">
      
            Returns an <code>NSFileHandle</code> object for the
            standard input descriptor. The returned object is
            a shared instance as there can only be one standard input
            per process.
          
    </div>
    <hr class="method-separator"/>
</div>
<div class="method">
    <h3><a name="method$NSFileHandle+fileHandleWithStandardOutput">fileHandleWithStandardOutput&nbsp;</a></h3>
    + (instancetype) <b>fileHandleWithStandardOutput</b>;<br />
    <div class="availability">
<b>Availability:</b> OpenStep</div>
<br />
    <div class="desc">
      
            Returns an <code>NSFileHandle</code> object for the
            standard output descriptor. The returned object is
            a shared instance as there can only be one standard
            output per process.
          
    </div>
    <hr class="method-separator"/>
</div>
<div class="method">
    <h3><a name="method$NSFileHandle-acceptConnectionInBackgroundAndNotify">acceptConnectionInBackgroundAndNotify&nbsp;</a></h3>
    - (void) <b>acceptConnectionInBackgroundAndNotify</b>;<br />
    <div class="availability">
<b>Availability:</b> OpenStep</div>
<br />
    <div class="desc">
      
            Asynchronously accept a stream-type socket
            connection and act as the (server) end of the
            communications channel. This instance should
            have been created by
            <a rel="gsdoc" href="#method$NSFileHandle-initWithFileDescriptor$">
              -initWithFileDescriptor:
            </a>

            with a stream-type socket created by the appropriate
            system routine. Posts a
            <code>
              NSFileHandleConnectionAcceptedNotification
            </code>
            when connection initiated, returning an
            <code>NSFileHandle</code> for the client side with
            that notification.
          
    </div>
    <hr class="method-separator"/>
</div>
<div class="method">
    <h3><a name="method$NSFileHandle-acceptConnectionInBackgroundAndNotifyForModes$">acceptConnectionInBackgroundAndNotifyForModes:&nbsp;</a></h3>
    - (void) <b>acceptConnectionInBackgroundAndNotifyForModes:</b> (<a rel="gsdoc" href="NSArray.html#class$NSArray">NSArray</a>*)modes;<br />
    <div class="availability">
<b>Availability:</b> OpenStep</div>
<br />
    <div class="desc">
      
            
    </p>
    <p>

              Asynchronously accept a stream-type socket
              connection and act as the (server) end of the
              communications channel. This instance
              should have been created by
              <a rel="gsdoc" href="#method$NSFileHandle-initWithFileDescriptor$">
                -initWithFileDescriptor:
              </a>

              with a stream-type socket created by the appropriate
              system routine. Posts a
              <code>
                NSFileHandleConnectionAcceptedNotification
              </code>
              when connection initiated, returning an
              <code>NSFileHandle</code> for the client side with
              that notification.
                </p>
    <p>
      
            
    </p>
    <p>

              The <var>modes</var> array specifies
              <a rel="gsdoc" href="NSRunLoop.html#class$NSRunLoop">NSRunLoop</a>

                <var>modes</var> that the notification can be
                posted in.
                  </p>
    <p>
      
          
    </div>
    <hr class="method-separator"/>
</div>
<div class="method">
    <h3><a name="method$NSFileHandle-availableData">availableData&nbsp;</a></h3>
    - (<a rel="gsdoc" href="NSData.html#class$NSData">NSData</a>*) <b>availableData</b>;<br />
    <div class="availability">
<b>Availability:</b> OpenStep</div>
<br />
    <div class="desc">
      
            Synchronously returns data available through
            this file or connection. If the handle represents a
            file, the entire contents from current file pointer
            to end are returned. If this is a network connection,
            reads what is available, blocking if nothing is
            available. Raises
            <code>NSFileHandleOperationException</code> if
            problem encountered.
          
    </div>
    <hr class="method-separator"/>
</div>
<div class="method">
    <h3><a name="method$NSFileHandle-closeFile">closeFile&nbsp;</a></h3>
    - (void) <b>closeFile</b>;<br />
    <div class="availability">
<b>Availability:</b> OpenStep</div>
<br />
    <div class="desc">
      
            Disallows further reading from read-access files
            or connections, and sends EOF on write-access files or
            connections. Descriptor is only
            <em>deleted</em> when this instance is deallocated.
          
    </div>
    <hr class="method-separator"/>
</div>
<div class="method">
    <h3><a name="method$NSFileHandle-fileDescriptor">fileDescriptor&nbsp;</a></h3>
    - (int) <b>fileDescriptor</b>;<br />
    <div class="availability">
<b>Availability:</b> OpenStep</div>
<br />
    <div class="desc">
      
            Return the underlying file descriptor for this
            instance.
          
    </div>
    <hr class="method-separator"/>
</div>
<div class="method">
    <h3><a name="method$NSFileHandle-getOffset$error$">getOffset:&nbsp;error:&nbsp;</a></h3>
    - (BOOL) <b>getOffset:</b> (unsigned long long*)offsetInFile<b> error:</b> (<a rel="gsdoc" href="NSError.html#class$NSError">NSError</a>**)error;<br />
    <div class="availability">
<b>Availability:</b> MacOS-X 10.15.0</div>
<br />
    <div class="desc">
      
            Get the current position in the file.
          
    </div>
    <hr class="method-separator"/>
</div>
<div class="method">
    <h3><a name="method$NSFileHandle-initWithFileDescriptor$">initWithFileDescriptor:&nbsp;</a></h3>
    - (id) <b>initWithFileDescriptor:</b> (int)desc;<br />
    <div class="availability">
<b>Availability:</b> OpenStep</div>
<br />
    <div class="desc">
      
            Initialize with <var>desc</var>, which can point
            to either a regular file or socket connection.
          
    </div>
    <hr class="method-separator"/>
</div>
<div class="method">
    <h3><a name="method$NSFileHandle-initWithFileDescriptor$closeOnDealloc$">initWithFileDescriptor:&nbsp;closeOnDealloc:&nbsp;</a></h3>
    - (id) <b>initWithFileDescriptor:</b> (int)desc<b> closeOnDealloc:</b> (BOOL)flag;<br />
    <div class="availability">
<b>Availability:</b> OpenStep</div>
<br />
    <div class="desc">
      
            Initialize with <var>desc</var>, which can point
            to either a regular file or socket connection. Close
            <var>desc</var> when this instance is deallocated if
            <var>flag</var> is <code>YES</code>.
          
    </div>
    <hr class="method-separator"/>
</div>
<div class="method">
    <h3><a name="method$NSFileHandle-initWithNativeHandle$">initWithNativeHandle:&nbsp;</a></h3>
    - (id) <b>initWithNativeHandle:</b> (void*)hdl;<br />
    <div class="availability">
<b>Availability:</b> OpenStep</div>
<br />
    <div class="desc">
      
            Windows-Unix compatibility support.
          
    </div>
    <hr class="method-separator"/>
</div>
<div class="method">
    <h3><a name="method$NSFileHandle-initWithNativeHandle$closeOnDealloc$">initWithNativeHandle:&nbsp;closeOnDealloc:&nbsp;</a></h3>
    - (id) <b>initWithNativeHandle:</b> (void*)hdl<b> closeOnDealloc:</b> (BOOL)flag;<br />
    <div class="availability">
<b>Availability:</b> OpenStep</div>
<br />
This is a designated initialiser for the class.<br />
    <div class="desc">
      
            Windows-Unix compatibility support.
          
    </div>
    <hr class="method-separator"/>
</div>
<div class="method">
    <h3><a name="method$NSFileHandle-nativeHandle">nativeHandle&nbsp;</a></h3>
    - (void*) <b>nativeHandle</b>;<br />
    <div class="availability">
<b>Availability:</b> OpenStep</div>
<br />
    <div class="desc">
      
            Windows-Unix compatibility support.
          
    </div>
    <hr class="method-separator"/>
</div>
<div class="method">
    <h3><a name="method$NSFileHandle-offsetInFile">offsetInFile&nbsp;</a></h3>
    - (unsigned long long) <b>offsetInFile</b>;<br />
    <div class="availability">
<b>Availability:</b> OpenStep</div>
<br />
    <div class="desc">
      
            Return current position in file, or raises exception
            if instance does not represent a regular file.
          
    </div>
    <hr class="method-separator"/>
</div>
<div class="method">
    <h3><a name="method$NSFileHandle-readDataOfLength$">readDataOfLength:&nbsp;</a></h3>
    - (<a rel="gsdoc" href="NSData.html#class$NSData">NSData</a>*) <b>readDataOfLength:</b> (unsigned int)len;<br />
    <div class="availability">
<b>Availability:</b> OpenStep</div>
<br />
    <div class="desc">
      
            Reads up to <var>len</var> bytes from file or
            communications channel into return data.
          
    </div>
    <hr class="method-separator"/>
</div>
<div class="method">
    <h3><a name="method$NSFileHandle-readDataToEndOfFile">readDataToEndOfFile&nbsp;</a></h3>
    - (<a rel="gsdoc" href="NSData.html#class$NSData">NSData</a>*) <b>readDataToEndOfFile</b>;<br />
    <div class="availability">
<b>Availability:</b> OpenStep</div>
<br />
    <div class="desc">
      
            Reads up to maximum <strong>unsigned</strong>
            <strong>int</strong> bytes from file or
            communications channel into return data.
            <br/> If the file is empty, returns an empty data
            item.
          
    </div>
    <hr class="method-separator"/>
</div>
<div class="method">
    <h3><a name="method$NSFileHandle-readInBackgroundAndNotify">readInBackgroundAndNotify&nbsp;</a></h3>
    - (void) <b>readInBackgroundAndNotify</b>;<br />
    <div class="availability">
<b>Availability:</b> OpenStep</div>
<br />
    <div class="desc">
      
            Call
            <a rel="gsdoc" href="#method$NSFileHandle-readInBackgroundAndNotifyForModes$">-readInBackgroundAndNotifyForModes:</a>
 with <code>nil</code> modes.
          
    </div>
    <hr class="method-separator"/>
</div>
<div class="method">
    <h3><a name="method$NSFileHandle-readInBackgroundAndNotifyForModes$">readInBackgroundAndNotifyForModes:&nbsp;</a></h3>
    - (void) <b>readInBackgroundAndNotifyForModes:</b> (<a rel="gsdoc" href="NSArray.html#class$NSArray">NSArray</a>*)modes;<br />
    <div class="availability">
<b>Availability:</b> OpenStep</div>
<br />
    <div class="desc">
      
            Set up an asynchronous read operation which will cause
            a notification to be sent when any amount of data (or end
            of file) is read. Note that the file handle will not
            continuously send notifications when data is
            available. If you want to continue to receive
            notifications, you need to send this message
            again after receiving a notification.
          
    </div>
    <hr class="method-separator"/>
</div>
<div class="method">
    <h3><a name="method$NSFileHandle-readToEndOfFileInBackgroundAndNotify">readToEndOfFileInBackgroundAndNotify&nbsp;</a></h3>
    - (void) <b>readToEndOfFileInBackgroundAndNotify</b>;<br />
    <div class="availability">
<b>Availability:</b> OpenStep</div>
<br />
    <div class="desc">
      
            Call
            <a rel="gsdoc" href="#method$NSFileHandle-readToEndOfFileInBackgroundAndNotifyForModes$">-readToEndOfFileInBackgroundAndNotifyForModes:</a>
 with <code>nil</code> modes.
          
    </div>
    <hr class="method-separator"/>
</div>
<div class="method">
    <h3><a name="method$NSFileHandle-readToEndOfFileInBackgroundAndNotifyForModes$">readToEndOfFileInBackgroundAndNotifyForModes:&nbsp;</a></h3>
    - (void) <b>readToEndOfFileInBackgroundAndNotifyForModes:</b> (<a rel="gsdoc" href="NSArray.html#class$NSArray">NSArray</a>*)modes;<br />
    <div class="availability">
<b>Availability:</b> OpenStep</div>
<br />
    <div class="desc">
      
            Set up an asynchronous read operation which will cause
            a notification to be sent when end of file is read.
          
    </div>
    <hr class="method-separator"/>
</div>
<div class="method">
    <h3><a name="method$NSFileHandle-seekToEndOfFile">seekToEndOfFile&nbsp;</a></h3>
    - (unsigned long long) <b>seekToEndOfFile</b>;<br />
    <div class="availability">
<b>Availability:</b> OpenStep</div>
<br />
    <div class="desc">
      
            Position file pointer at end of file, raising
            exception if instance does not represent a
            regular file.
          
    </div>
    <hr class="method-separator"/>
</div>
<div class="method">
    <h3><a name="method$NSFileHandle-seekToFileOffset$">seekToFileOffset:&nbsp;</a></h3>
    - (void) <b>seekToFileOffset:</b> (unsigned long long)pos;<br />
    <div class="availability">
<b>Availability:</b> OpenStep</div>
<br />
    <div class="desc">
      
            Position file pointer at <var>pos</var>, raising
            exception if instance does not represent a
            regular file.
          
    </div>
    <hr class="method-separator"/>
</div>
<div class="method">
    <h3><a name="method$NSFileHandle-synchronizeFile">synchronizeFile&nbsp;</a></h3>
    - (void) <b>synchronizeFile</b>;<br />
    <div class="availability">
<b>Availability:</b> OpenStep</div>
<br />
    <div class="desc">
      
            Flush in-memory buffer to file or connection, then
            return.
          
    </div>
    <hr class="method-separator"/>
</div>
<div class="method">
    <h3><a name="method$NSFileHandle-truncateFileAtOffset$">truncateFileAtOffset:&nbsp;</a></h3>
    - (void) <b>truncateFileAtOffset:</b> (unsigned long long)pos;<br />
    <div class="availability">
<b>Availability:</b> OpenStep</div>
<br />
    <div class="desc">
      
            Chops file beyond <var>pos</var> then sets file
            pointer to that point.
          
    </div>
    <hr class="method-separator"/>
</div>
<div class="method">
    <h3><a name="method$NSFileHandle-waitForDataInBackgroundAndNotify">waitForDataInBackgroundAndNotify&nbsp;</a></h3>
    - (void) <b>waitForDataInBackgroundAndNotify</b>;<br />
    <div class="availability">
<b>Availability:</b> OpenStep</div>
<br />
    <div class="desc">
      
            Call
            <a rel="gsdoc" href="#method$NSFileHandle-waitForDataInBackgroundAndNotifyForModes$">-waitForDataInBackgroundAndNotifyForModes:</a>
 with <code>nil</code> modes.
          
    </div>
    <hr class="method-separator"/>
</div>
<div class="method">
    <h3><a name="method$NSFileHandle-waitForDataInBackgroundAndNotifyForModes$">waitForDataInBackgroundAndNotifyForModes:&nbsp;</a></h3>
    - (void) <b>waitForDataInBackgroundAndNotifyForModes:</b> (<a rel="gsdoc" href="NSArray.html#class$NSArray">NSArray</a>*)modes;<br />
    <div class="availability">
<b>Availability:</b> OpenStep</div>
<br />
    <div class="desc">
      
            Set up to provide a notification when data can be read
            from the handle.
          
    </div>
    <hr class="method-separator"/>
</div>
<div class="method">
    <h3><a name="method$NSFileHandle-writeData$">writeData:&nbsp;</a></h3>
    - (void) <b>writeData:</b> (<a rel="gsdoc" href="NSData.html#class$NSData">NSData</a>*)item;<br />
    <div class="availability">
<b>Availability:</b> OpenStep</div>
<br />
    <div class="desc">
      
            Synchronously writes given data
            <var>item</var> to file or connection.
          
    </div>
    <hr class="method-separator"/>
</div>

          <h1><a name="002000000000">
        Software documentation for the NSPipe class
      </a></h1>
    <h2 class="class"><a name="class$NSPipe">NSPipe</a> : <a rel="gsdoc" href="NSObject.html#class$NSObject">NSObject</a></h2>
<svg width="126pt" height="116pt"
 viewBox="0.00 0.00 126.00 116.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 112)">
<title>class_NSPipe</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-112 122,-112 122,4 -4,4"/>
<!-- NSObject -->
<g id="node1" class="node">
<title>NSObject</title>
<g id="a_node1"><a xlink:href="NSObject.html#class$NSObject" xlink:title="NSObject">
<polygon fill="lightgrey" stroke="black" points="118,-108 0,-108 0,-72 118,-72 118,-108"/>
<text text-anchor="middle" x="59" y="-83.8" font-family="Times,serif" font-size="24.00" fill="blue">NSObject</text>
</a>
</g>
</g>
<!-- NSPipe -->
<g id="node2" class="node">
<title>NSPipe</title>
<polygon fill="lightgrey" stroke="black" points="104.5,-36 13.5,-36 13.5,0 104.5,0 104.5,-36"/>
<text text-anchor="middle" x="59" y="-11.8" font-family="Times,serif" font-size="24.00" fill="green">NSPipe</text>
</g>
<!-- NSObject&#45;&gt;NSPipe -->
<g id="edge1" class="edge">
<title>NSObject&#45;&gt;NSPipe</title>
<path fill="none" stroke="black" d="M59,-71.7C59,-63.98 59,-54.71 59,-46.11"/>
<polygon fill="black" stroke="black" points="62.5,-46.1 59,-36.1 55.5,-46.1 62.5,-46.1"/>
</g>
</g>
</svg>
    <blockquote class="declared">
      <dl>
        <dt><b>Declared in:</b></dt>
        <dd>Foundation/NSFileHandle.h</dd>
      </dl>
    </blockquote>
    <div class="availability">
<b>Availability:</b> OpenStep</div>
<br />
    <div class="desc">
      
          
    </p>
    <p>

            The NSPipe provides an encapsulation of the UNIX
            concept of pipe. <br/> With NSPipe, it is possible
            to redirect the standard input or standard output.
              </p>
    <p>
      
          
    </p>
    <p>

            The file handles created by NSPipe are automatically
            closed when they are no longer in use (ie when the
            NSPipe instance is deallocated), so you don&apos;t need
            to close them explicitly.
              </p>
    <p>
      
        
    </div>
<div class="global_method_index">
    <b>Method summary</b>
    <ul>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSPipe+pipe">+pipe</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSPipe-fileHandleForReading">-fileHandleForReading</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSPipe-fileHandleForWriting">-fileHandleForWriting</a></li>
    </ul>
</div>
    <hr width="50%" align="left" />
<div class="method">
    <h3><a name="method$NSPipe+pipe">pipe&nbsp;</a></h3>
    + (id) <b>pipe</b>;<br />
    <div class="availability">
<b>Availability:</b> OpenStep</div>
<br />
    <div class="desc">
      
            Returns a newly allocated and initialized NSPipe
            object that has been sent an autorelease message.
          
    </div>
    <hr class="method-separator"/>
</div>
<div class="method">
    <h3><a name="method$NSPipe-fileHandleForReading">fileHandleForReading&nbsp;</a></h3>
    - (<a rel="gsdoc" href="#class$NSFileHandle">NSFileHandle</a>*) <b>fileHandleForReading</b>;<br />
    <div class="availability">
<b>Availability:</b> OpenStep</div>
<br />
    <div class="desc">
      
            Returns the file handle for reading from the pipe.
          
    </div>
    <hr class="method-separator"/>
</div>
<div class="method">
    <h3><a name="method$NSPipe-fileHandleForWriting">fileHandleForWriting&nbsp;</a></h3>
    - (<a rel="gsdoc" href="#class$NSFileHandle">NSFileHandle</a>*) <b>fileHandleForWriting</b>;<br />
    <div class="availability">
<b>Availability:</b> OpenStep</div>
<br />
    <div class="desc">
      
            Returns the file handle for writing to the pipe.
          
    </div>
    <hr class="method-separator"/>
</div>

          <h1><a name="003000000000">
        Software documentation for the
        NSFileHandle(GNUstepExtensions)
        category
      </a></h1>
    <h2><a rel="gsdoc" href="#class$NSFileHandle">NSFileHandle</a>(<a name="category$NSFileHandle(GNUstepExtensions)">GNUstepExtensions</a>)</h2>
    <blockquote class="declared">
      <dl>
        <dt><b>Declared in:</b></dt>
        <dd>Foundation/NSFileHandle.h</dd>
      </dl>
    </blockquote>
    <div class="availability">
<b>Availability:</b> Not in OpenStep/MacOS-X</div>
<br />
    <div class="desc">
      
          A set of convenience methods for utilizing the socket
          communications capabilities of the
          <a rel="gsdoc" href="#class$NSFileHandle">NSFileHandle</a>

            class.
        
    </div>
<div class="global_method_index">
    <b>Method summary</b>
    <ul>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle(GNUstepExtensions)+fileHandleAsClientAtAddress$service$protocol$">+fileHandleAsClientAtAddress:service:protocol:</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle(GNUstepExtensions)+fileHandleAsClientInBackgroundAtAddress$service$protocol$">+fileHandleAsClientInBackgroundAtAddress:service:protocol:</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle(GNUstepExtensions)+fileHandleAsClientInBackgroundAtAddress$service$protocol$forModes$">+fileHandleAsClientInBackgroundAtAddress:service:protocol:forModes:</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle(GNUstepExtensions)+fileHandleAsServerAtAddress$service$protocol$">+fileHandleAsServerAtAddress:service:protocol:</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle(GNUstepExtensions)-readDataInBackgroundAndNotifyLength$">-readDataInBackgroundAndNotifyLength:</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle(GNUstepExtensions)-readDataInBackgroundAndNotifyLength$forModes$">-readDataInBackgroundAndNotifyLength:forModes:</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle(GNUstepExtensions)-readInProgress">-readInProgress</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle(GNUstepExtensions)-socketAddress">-socketAddress</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle(GNUstepExtensions)-socketLocalAddress">-socketLocalAddress</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle(GNUstepExtensions)-socketLocalService">-socketLocalService</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle(GNUstepExtensions)-socketProtocol">-socketProtocol</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle(GNUstepExtensions)-socketService">-socketService</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle(GNUstepExtensions)-useCompression">-useCompression</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle(GNUstepExtensions)-writeInBackgroundAndNotify$">-writeInBackgroundAndNotify:</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle(GNUstepExtensions)-writeInBackgroundAndNotify$forModes$">-writeInBackgroundAndNotify:forModes:</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle(GNUstepExtensions)-writeInProgress">-writeInProgress</a></li>
    </ul>
</div>
    <hr width="50%" align="left" />
<div class="method">
    <h3><a name="method$NSFileHandle(GNUstepExtensions)+fileHandleAsClientAtAddress$service$protocol$">fileHandleAsClientAtAddress:&nbsp;service:&nbsp;protocol:&nbsp;</a></h3>
    + (id) <b>fileHandleAsClientAtAddress:</b> (<a rel="gsdoc" href="NSString.html#class$NSString">NSString</a>*)address<b> service:</b> (<a rel="gsdoc" href="NSString.html#class$NSString">NSString</a>*)service<b> protocol:</b> (<a rel="gsdoc" href="NSString.html#class$NSString">NSString</a>*)protocol;<br />
    <div class="availability">
<b>Availability:</b> Not in OpenStep/MacOS-X</div>
<br />
    <div class="desc">
      
            Opens an outgoing network connection by initiating an
            asynchronous connection (see
            <a rel="gsdoc" href="#method$NSFileHandle(GNUstepExtensions)+fileHandleAsClientInBackgroundAtAddress$service$protocol$forModes$">+fileHandleAsClientInBackgroundAtAddress:service:protocol:forModes:</a>
) and waiting for it to succeed, fail, or time out.
          
    </div>
    <hr class="method-separator"/>
</div>
<div class="method">
    <h3><a name="method$NSFileHandle(GNUstepExtensions)+fileHandleAsClientInBackgroundAtAddress$service$protocol$">fileHandleAsClientInBackgroundAtAddress:&nbsp;service:&nbsp;protocol:&nbsp;</a></h3>
    + (id) <b>fileHandleAsClientInBackgroundAtAddress:</b> (<a rel="gsdoc" href="NSString.html#class$NSString">NSString</a>*)address<b> service:</b> (<a rel="gsdoc" href="NSString.html#class$NSString">NSString</a>*)service<b> protocol:</b> (<a rel="gsdoc" href="NSString.html#class$NSString">NSString</a>*)protocol;<br />
    <div class="availability">
<b>Availability:</b> Not in OpenStep/MacOS-X</div>
<br />
    <div class="desc">
      
            Opens an outgoing network connection asynchronously
            using
            <a rel="gsdoc" href="#method$NSFileHandle(GNUstepExtensions)+fileHandleAsClientInBackgroundAtAddress$service$protocol$forModes$">[+fileHandleAsClientInBackgroundAtAddress:service:protocol:forModes:]</a>

          
    </div>
    <hr class="method-separator"/>
</div>
<div class="method">
    <h3><a name="method$NSFileHandle(GNUstepExtensions)+fileHandleAsClientInBackgroundAtAddress$service$protocol$forModes$">fileHandleAsClientInBackgroundAtAddress:&nbsp;service:&nbsp;protocol:&nbsp;forModes:&nbsp;</a></h3>
    + (id) <b>fileHandleAsClientInBackgroundAtAddress:</b> (<a rel="gsdoc" href="NSString.html#class$NSString">NSString</a>*)address<b> service:</b> (<a rel="gsdoc" href="NSString.html#class$NSString">NSString</a>*)service<b> protocol:</b> (<a rel="gsdoc" href="NSString.html#class$NSString">NSString</a>*)protocol<b> forModes:</b> (<a rel="gsdoc" href="NSArray.html#class$NSArray">NSArray</a>*)modes;<br />
    <div class="availability">
<b>Availability:</b> Not in OpenStep/MacOS-X</div>
<br />
    <div class="desc">
      
            
    </p>
    <p>

              Opens an outgoing network connection
              asynchronously.
                </p>
    <p>
      
            
      <ul>
        <li>
          
                The <var>address</var> is the name (or IP dotted
                quad) of the machine to which the connection
                should be made.
              
        </li>
        <li>
          
                The <var>service</var> is the name (or number) of
                the port to which the connection should be made.
              
        </li>
        <li>
          
                The <var>protocol</var> is provided so support
                different network protocols, but at present
                only &apos;tcp&apos; is supported. However, a
                <var>protocol</var> specification of the form
                &apos;socks-...&apos; can be used to control socks5
                support. <br/> If &apos;...&apos; is empty (ie the
                string is just &apos;socks-&apos; then the connection is
                <em>not</em> made via a socks server. <br/>
                Otherwise, the text &apos;...&apos; must be the name
                of the host on which the socks5 server is running,
                with an optional port number separated from the
                host name by a colon. <br/> Alternatively a
                prefix of the form &apos;bind-&apos; followed by an IP
                <var>address</var> may be used (for non-socks
                connections) to ensure that the connection
                is made from the specified <var>address</var>.
              
        </li>
        <li>
          
                If <var>modes</var> is <code>nil</code> or empty,
                uses NSDefaultRunLoopMode.
              
        </li>
      </ul>
      
            
    </p>
    <p>

              This method supports connection through a firewall
              via socks5. The socks5 connection may be controlled
              via the <var>protocol</var> argument, but if no socks
              information is supplied here, the
              <em>GSSOCKS</em> user default will be used, and
              failing that, the <em>SOCKS5_SERVER</em> or
              <em>SOCKS_SERVER</em> environment variables will be
              used to set the socks server. If none of these
              mechanisms specify a socks server, the
              connection will be made directly rather than
              through socks.
                </p>
    <p>
      
          
    </div>
    <hr class="method-separator"/>
</div>
<div class="method">
    <h3><a name="method$NSFileHandle(GNUstepExtensions)+fileHandleAsServerAtAddress$service$protocol$">fileHandleAsServerAtAddress:&nbsp;service:&nbsp;protocol:&nbsp;</a></h3>
    + (id) <b>fileHandleAsServerAtAddress:</b> (<a rel="gsdoc" href="NSString.html#class$NSString">NSString</a>*)address<b> service:</b> (<a rel="gsdoc" href="NSString.html#class$NSString">NSString</a>*)service<b> protocol:</b> (<a rel="gsdoc" href="NSString.html#class$NSString">NSString</a>*)protocol;<br />
    <div class="availability">
<b>Availability:</b> Not in OpenStep/MacOS-X</div>
<br />
    <div class="desc">
      
            Opens a network server socket and listens for
            incoming connections using the specified
            <var>service</var> and <var>protocol</var>.
            
      <ul>
        <li>
          
                The <var>service</var> is the name (or number) of
                the port to which the connection should be made.
              
        </li>
        <li>
          
                The <var>protocol</var> may at present only be
                &apos;tcp&apos;
              
        </li>
      </ul>
      
          
    </div>
    <hr class="method-separator"/>
</div>
<div class="method">
    <h3><a name="method$NSFileHandle(GNUstepExtensions)-readDataInBackgroundAndNotifyLength$">readDataInBackgroundAndNotifyLength:&nbsp;</a></h3>
    - (void) <b>readDataInBackgroundAndNotifyLength:</b> (unsigned)len;<br />
    <div class="availability">
<b>Availability:</b> Not in OpenStep/MacOS-X</div>
<br />
    <div class="desc">
      
            Call
            <a rel="gsdoc" href="#method$NSFileHandle(GNUstepExtensions)-readDataInBackgroundAndNotifyLength$forModes$">-readDataInBackgroundAndNotifyLength:forModes:</a>
 with <code>nil</code> modes.
          
    </div>
    <hr class="method-separator"/>
</div>
<div class="method">
    <h3><a name="method$NSFileHandle(GNUstepExtensions)-readDataInBackgroundAndNotifyLength$forModes$">readDataInBackgroundAndNotifyLength:&nbsp;forModes:&nbsp;</a></h3>
    - (void) <b>readDataInBackgroundAndNotifyLength:</b> (unsigned)len<b> forModes:</b> (<a rel="gsdoc" href="NSArray.html#class$NSArray">NSArray</a>*)modes;<br />
    <div class="availability">
<b>Availability:</b> Not in OpenStep/MacOS-X</div>
<br />
    <div class="desc">
      
            Set up an asynchronous read operation which will cause
            a notification to be sent when the specified amount of
            data (or end of file) is read.
          
    </div>
    <hr class="method-separator"/>
</div>
<div class="method">
    <h3><a name="method$NSFileHandle(GNUstepExtensions)-readInProgress">readInProgress&nbsp;</a></h3>
    - (BOOL) <b>readInProgress</b>;<br />
    <div class="availability">
<b>Availability:</b> Not in OpenStep/MacOS-X</div>
<br />
    <div class="desc">
      
            Returns a boolean to indicate whether a read
            operation of any kind is in progress on the
            handle.
          
    </div>
    <hr class="method-separator"/>
</div>
<div class="method">
    <h3><a name="method$NSFileHandle(GNUstepExtensions)-socketAddress">socketAddress&nbsp;</a></h3>
    - (<a rel="gsdoc" href="NSString.html#class$NSString">NSString</a>*) <b>socketAddress</b>;<br />
    <div class="availability">
<b>Availability:</b> Not in OpenStep/MacOS-X</div>
<br />
    <div class="desc">
      
            Returns the host address of the network connection
            represented by the file handle. If this handle
            is an incoming connection which was received by a local
            server handle, this is the name or address of the
            client machine.
          
    </div>
    <hr class="method-separator"/>
</div>
<div class="method">
    <h3><a name="method$NSFileHandle(GNUstepExtensions)-socketLocalAddress">socketLocalAddress&nbsp;</a></h3>
    - (<a rel="gsdoc" href="NSString.html#class$NSString">NSString</a>*) <b>socketLocalAddress</b>;<br />
    <div class="availability">
<b>Availability:</b> Not in OpenStep/MacOS-X</div>
<br />
    <div class="desc">
      
            Returns the local address of the network connection
            or <code>nil</code>.
          
    </div>
    <hr class="method-separator"/>
</div>
<div class="method">
    <h3><a name="method$NSFileHandle(GNUstepExtensions)-socketLocalService">socketLocalService&nbsp;</a></h3>
    - (<a rel="gsdoc" href="NSString.html#class$NSString">NSString</a>*) <b>socketLocalService</b>;<br />
    <div class="availability">
<b>Availability:</b> Not in OpenStep/MacOS-X</div>
<br />
    <div class="desc">
      
            Returns the local service/port of the network
            connection or <code>nil</code>.
          
    </div>
    <hr class="method-separator"/>
</div>
<div class="method">
    <h3><a name="method$NSFileHandle(GNUstepExtensions)-socketProtocol">socketProtocol&nbsp;</a></h3>
    - (<a rel="gsdoc" href="NSString.html#class$NSString">NSString</a>*) <b>socketProtocol</b>;<br />
    <div class="availability">
<b>Availability:</b> Not in OpenStep/MacOS-X</div>
<br />
    <div class="desc">
      
            Returns the name of the protocol in use for the
            network connection represented by the file handle.
          
    </div>
    <hr class="method-separator"/>
</div>
<div class="method">
    <h3><a name="method$NSFileHandle(GNUstepExtensions)-socketService">socketService&nbsp;</a></h3>
    - (<a rel="gsdoc" href="NSString.html#class$NSString">NSString</a>*) <b>socketService</b>;<br />
    <div class="availability">
<b>Availability:</b> Not in OpenStep/MacOS-X</div>
<br />
    <div class="desc">
      
            Returns the name (or number) of the service
            (network port) in use for the network connection
            represented by the file handle.
          
    </div>
    <hr class="method-separator"/>
</div>
<div class="method">
    <h3><a name="method$NSFileHandle(GNUstepExtensions)-useCompression">useCompression&nbsp;</a></h3>
    - (BOOL) <b>useCompression</b>;<br />
    <div class="availability">
<b>Availability:</b> Not in OpenStep/MacOS-X</div>
<br />
    <div class="desc">
      
            
    </p>
    <p>

              Return a flag to indicate whether compression has
              been turned on for the file handle... this is only
              available on systems where GNUstep was built
              with &apos;zlib&apos; support for compressing/decompressing
              data.
                </p>
    <p>
      
            
    </p>
    <p>

              On systems which support it, this method may be called
              after a file handle has been initialised to turn on
              compression or decompression of the data
              being written/read.
                </p>
    <p>
      
            Returns <code>YES</code> on success,
            <code>NO</code> on failure. <br/> Reasons for
            failure are - <br/>
            
      <ul>
        <li>
          Not supported/built in to GNUstep
        </li>
        <li>
          File handle has been closed
        </li>
        <li>
          
                File handle is open for both read and write
              
        </li>
        <li>
          
                Failure in compression/decompression library
              
        </li>
      </ul>
      
          
    </div>
    <hr class="method-separator"/>
</div>
<div class="method">
    <h3><a name="method$NSFileHandle(GNUstepExtensions)-writeInBackgroundAndNotify$">writeInBackgroundAndNotify:&nbsp;</a></h3>
    - (void) <b>writeInBackgroundAndNotify:</b> (<a rel="gsdoc" href="NSData.html#class$NSData">NSData</a>*)item;<br />
    <div class="availability">
<b>Availability:</b> Not in OpenStep/MacOS-X</div>
<br />
    <div class="desc">
      
            Call
            <a rel="gsdoc" href="#method$NSFileHandle(GNUstepExtensions)-writeInBackgroundAndNotify$forModes$">-writeInBackgroundAndNotify:forModes:</a>
 with <code>nil</code> modes.
          
    </div>
    <hr class="method-separator"/>
</div>
<div class="method">
    <h3><a name="method$NSFileHandle(GNUstepExtensions)-writeInBackgroundAndNotify$forModes$">writeInBackgroundAndNotify:&nbsp;forModes:&nbsp;</a></h3>
    - (void) <b>writeInBackgroundAndNotify:</b> (<a rel="gsdoc" href="NSData.html#class$NSData">NSData</a>*)item<b> forModes:</b> (<a rel="gsdoc" href="NSArray.html#class$NSArray">NSArray</a>*)modes;<br />
    <div class="availability">
<b>Availability:</b> Not in OpenStep/MacOS-X</div>
<br />
    <div class="desc">
      
            Write the specified data asynchronously, and notify
            on completion.
          
    </div>
    <hr class="method-separator"/>
</div>
<div class="method">
    <h3><a name="method$NSFileHandle(GNUstepExtensions)-writeInProgress">writeInProgress&nbsp;</a></h3>
    - (BOOL) <b>writeInProgress</b>;<br />
    <div class="availability">
<b>Availability:</b> Not in OpenStep/MacOS-X</div>
<br />
    <div class="desc">
      
            Returns a boolean to indicate whether a write
            operation of any kind is in progress on the
            handle. An outgoing network connection attempt (as
            a client) is considered to be a write operation.
          
    </div>
    <hr class="method-separator"/>
</div>

          <h1><a name="004000000000">
        Software documentation for the
        NSFileHandle(GNUstepTLS) category
      </a></h1>
    <h2><a rel="gsdoc" href="#class$NSFileHandle">NSFileHandle</a>(<a name="category$NSFileHandle(GNUstepTLS)">GNUstepTLS</a>)</h2>
    <blockquote class="declared">
      <dl>
        <dt><b>Declared in:</b></dt>
        <dd>Foundation/NSFileHandle.h</dd>
      </dl>
    </blockquote>
    <div class="availability">
<b>Availability:</b> Not in OpenStep/MacOS-X</div>
<br />
    <div class="desc">
      
          Where OpenSSL is available, you can use the subclass
          returned by
          <a rel="gsdoc" href="#method$NSFileHandle(GNUstepTLS)+sslClass">
            +sslClass
          </a>

          to handle SSL connections. <br/> The
          <a rel="gsdoc" href="#method$NSFileHandle(GNUstepTLS)-sslAccept">
            -sslAccept
          </a>

          method is used to do SSL handshake and start an
          encrypted session on a channel where the connection
          was initiated from the far end. <br/> The
          <a rel="gsdoc" href="#method$NSFileHandle(GNUstepTLS)-sslConnect">
            -sslConnect
          </a>

          method is used to do SSL handshake and start an
          encrypted session on a channel where the connection
          was initiated from the near end. <br/> The
          <a rel="gsdoc" href="#method$NSFileHandle(GNUstepTLS)-sslDisconnect">
            -sslDisconnect
          </a>

          method is used to end the encrypted session. The
          <a rel="gsdoc" href="#method$NSFileHandle(GNUstepTLS)-sslSetCertificate$privateKey$PEMpasswd$">-sslSetCertificate:privateKey:PEMpasswd:</a>
 method is used to establish a client certificate before starting an encrypted session. <br/> NB. Some of these methods may block while performing I/O on the network connection, (though they should run the current runloop while doing so) so you should structure your code to handle that. In particular, if you are writing a server application, you should initiate a background accept to allow another incoming connection <em>before</em> you perform an <a rel="gsdoc" href="#method$NSFileHandle(GNUstepTLS)-sslAccept">-sslAccept</a>
 on a connection you have just accepted.
        
    </div>
<div class="global_method_index">
    <b>Method summary</b>
    <ul>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle(GNUstepTLS)+setData$forTLSFile$">+setData:forTLSFile:</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle(GNUstepTLS)+sslClass">+sslClass</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle(GNUstepTLS)-sslAccept">-sslAccept</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle(GNUstepTLS)-sslConnect">-sslConnect</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle(GNUstepTLS)-sslDisconnect">-sslDisconnect</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle(GNUstepTLS)-sslHandshakeEstablished$outgoing$">-sslHandshakeEstablished:outgoing:</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle(GNUstepTLS)-sslIssuer">-sslIssuer</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle(GNUstepTLS)-sslOwner">-sslOwner</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle(GNUstepTLS)-sslSetCertificate$privateKey$PEMpasswd$">-sslSetCertificate:privateKey:PEMpasswd:</a></li>
      <li><a rel="gsdoc" href="NSFileHandle.html#method$NSFileHandle(GNUstepTLS)-sslSetOptions$">-sslSetOptions:</a></li>
    </ul>
</div>
    <hr width="50%" align="left" />
<div class="method">
    <h3><a name="method$NSFileHandle(GNUstepTLS)+setData$forTLSFile$">setData:&nbsp;forTLSFile:&nbsp;</a></h3>
    + (void) <b>setData:</b> (<a rel="gsdoc" href="NSData.html#class$NSData">NSData</a>*)data<b> forTLSFile:</b> (<a rel="gsdoc" href="NSString.html#class$NSString">NSString</a>*)fileName;<br />
    <div class="availability">
<b>Availability:</b> Not in OpenStep/MacOS-X</div>
<br />
    <div class="desc">
      
            Sets the known (cached) <var>data</var> content for
            the specified file name. <br/> Calling this with a
            <code>nil</code> <var>data</var> object will remove
            any existing value from the cache. <br/> You may use
            this method to control what <var>data</var> is used
            for specified file names when those file names are used
            as a result of SSL/TLS options being set for a file
            handle or stream.
          
    </div>
    <hr class="method-separator"/>
</div>
<div class="method">
    <h3><a name="method$NSFileHandle(GNUstepTLS)+sslClass">sslClass&nbsp;</a></h3>
    + (Class) <b>sslClass</b>;<br />
    <div class="availability">
<b>Availability:</b> Not in OpenStep/MacOS-X</div>
<br />
    <div class="desc">
      
            Returns the class to handle ssl enabled
            connections. <br/> returns the concrete class
            used to implement SSL/TLS connections.
          
    </div>
    <hr class="method-separator"/>
</div>
<div class="method">
    <h3><a name="method$NSFileHandle(GNUstepTLS)-sslAccept">sslAccept&nbsp;</a></h3>
    - (BOOL) <b>sslAccept</b>;<br />
    <div class="availability">
<b>Availability:</b> Not in OpenStep/MacOS-X</div>
<br />
    <div class="desc">
      
            Repeatedly attempt an incoming handshake for up
            to 30 seconds or until the handshake completes.
          
    </div>
    <hr class="method-separator"/>
</div>
<div class="method">
    <h3><a name="method$NSFileHandle(GNUstepTLS)-sslConnect">sslConnect&nbsp;</a></h3>
    - (BOOL) <b>sslConnect</b>;<br />
    <div class="availability">
<b>Availability:</b> Not in OpenStep/MacOS-X</div>
<br />
    <div class="desc">
      
            Repeatedly attempt an outgoing handshake for up
            to 30 seconds or until the handshake completes.
          
    </div>
    <hr class="method-separator"/>
</div>
<div class="method">
    <h3><a name="method$NSFileHandle(GNUstepTLS)-sslDisconnect">sslDisconnect&nbsp;</a></h3>
    - (void) <b>sslDisconnect</b>;<br />
    <div class="availability">
<b>Availability:</b> Not in OpenStep/MacOS-X</div>
<br />
An empty method provided for subclasses to override.<br />
    <div class="desc">
      
            Shuts down the SSL connection to the system that the
            handle is talking to.
          
    </div>
    <hr class="method-separator"/>
</div>
<div class="method">
    <h3><a name="method$NSFileHandle(GNUstepTLS)-sslHandshakeEstablished$outgoing$">sslHandshakeEstablished:&nbsp;outgoing:&nbsp;</a></h3>
    - (BOOL) <b>sslHandshakeEstablished:</b> (BOOL*)result<b> outgoing:</b> (BOOL)isOutgoing;<br />
    <div class="availability">
<b>Availability:</b> Not in OpenStep/MacOS-X</div>
<br />
An empty method provided for subclasses to override.<br />
    <div class="desc">
      
            Make a non-blocking handshake attempt. Calls to this
            method should be repeated until the method returns
            <code>YES</code> indicating that the handshake
            completed. If the method returns
            <code>YES</code> indicating completion of the
            handshake, the <var>result</var> indicates
            whether the handshake succeeded in establishing a
            connection or not. <br/> The default
            implementation simply returns
            <code>YES</code> and sets <var>result</var> to
            <code>NO</code>. <br/> This is implemented by an
            SSL handling subclass to perform real work.
          
    </div>
    <hr class="method-separator"/>
</div>
<div class="method">
    <h3><a name="method$NSFileHandle(GNUstepTLS)-sslIssuer">sslIssuer&nbsp;</a></h3>
    - (<a rel="gsdoc" href="NSString.html#class$NSString">NSString</a>*) <b>sslIssuer</b>;<br />
    <div class="availability">
<b>Availability:</b> Not in OpenStep/MacOS-X</div>
<br />
    <div class="desc">
      
            If the session verified a certificate from the remote
            end, returns the name of the certificate issuer in the
            form &quot;C=xxxx,O=yyyy,CN=zzzz&quot; as described in RFC2253.
            Otherwise returns <code>nil</code>.
          
    </div>
    <hr class="method-separator"/>
</div>
<div class="method">
    <h3><a name="method$NSFileHandle(GNUstepTLS)-sslOwner">sslOwner&nbsp;</a></h3>
    - (<a rel="gsdoc" href="NSString.html#class$NSString">NSString</a>*) <b>sslOwner</b>;<br />
    <div class="availability">
<b>Availability:</b> Not in OpenStep/MacOS-X</div>
<br />
    <div class="desc">
      
            If the session verified a certificate from the remote
            end, returns the name of the certificate owner in the
            form &quot;C=xxxx,O=yyyy,CN=zzzz&quot; as described in RFC2253.
            Otherwise returns <code>nil</code>.
          
    </div>
    <hr class="method-separator"/>
</div>
<div class="method">
    <h3><a name="method$NSFileHandle(GNUstepTLS)-sslSetCertificate$privateKey$PEMpasswd$">sslSetCertificate:&nbsp;privateKey:&nbsp;PEMpasswd:&nbsp;</a></h3>
    - (void) <b>sslSetCertificate:</b> (<a rel="gsdoc" href="NSString.html#class$NSString">NSString</a>*)certFile<b> privateKey:</b> (<a rel="gsdoc" href="NSString.html#class$NSString">NSString</a>*)privateKey<b> PEMpasswd:</b> (<a rel="gsdoc" href="NSString.html#class$NSString">NSString</a>*)PEMpasswd;<br />
    <div class="availability">
<b>Availability:</b> Not in OpenStep/MacOS-X</div>
<br />
    <div class="desc">
      
            Deprecated... use
            <a rel="gsdoc" href="#method$NSFileHandle(GNUstepTLS)-sslSetOptions$">
              -sslSetOptions:
            </a>

            instead
          
    </div>
    <hr class="method-separator"/>
</div>
<div class="method">
    <h3><a name="method$NSFileHandle(GNUstepTLS)-sslSetOptions$">sslSetOptions:&nbsp;</a></h3>
    - (<a rel="gsdoc" href="NSString.html#class$NSString">NSString</a>*) <b>sslSetOptions:</b> (<a rel="gsdoc" href="NSDictionary.html#class$NSDictionary">NSDictionary</a>*)options;<br />
    <div class="availability">
<b>Availability:</b> Not in OpenStep/MacOS-X</div>
<br />
An empty method provided for subclasses to override.<br />
    <div class="desc">
      
            Sets <var>options</var> to be used to configure this
            channel before the handshake. <br/> Returns
            <code>nil</code> on success, or an error message if
            some <var>options</var> could not be set. <br/> You
            may use the same <var>options</var> as property
            settings with the GNUstep implementation of
            NSStream. <br/> Expects key value pairs with the
            following names/meanings:
            
      <dl>
        <dt>GSTLSCAFile</dt>
        <dd>
          
                A string identifying the full path to the file
                containing any trusted certificate
                authorities to be used when verifying a
                certificate presented by the remote end of
                a connection.
              
        </dd>
        <dt>GSTLSCertificateFile</dt>
        <dd>
          
                The path to a PEM encoded certificate used to
                identify this end of the connection. This
                option <em>must</em> be set for handing an
                incoming connection, but is optional for
                outgoing connections. <br/> This must be used
                in conjunction with GSTLSCertificateKeyFile.
              
        </dd>
        <dt>GSTLSCertificateKeyFile</dt>
        <dd>
          
                The path to a PEM encoded key used to unlock the
                certificate file for the connection. The
                key in the file may or may not be encrypted, but if
                it is encrypted you must specify
                GSTLSCertificateKeyPassword.
              
        </dd>
        <dt>GSTLSCertificateKeyPassword</dt>
        <dd>
          
                A string to be used as the password to decrypt a key
                which was specified using GSTLSKeyPassword.
              
        </dd>
        <dt>GSTLSDebug</dt>
        <dd>
          
                A boolean specifying whether diagnostic debug is to
                be enabled to log information about a connection
                where the handshake fails. <br/>
              
        </dd>
        <dt>GSTLSIssuers</dt>
        <dd>
          
                An array of distinguished names (in RFC4514 format)
                listing the permitted issuers of the remote
                certificate. If this is present and the
                issuer of the remote certificate is not in the
                array, the connection handshake is failed.
              
        </dd>
        <dt>GSTLSOwners</dt>
        <dd>
          
                An array of distinguished names (in RFC4514 format)
                listing the permitted owners/subjects of the
                remote certificate. If this is present and the
                owner/subject of the remote certificate
                is not in the array, the connection handshake is
                failed.
              
        </dd>
        <dt>GSTLSPriority</dt>
        <dd>
          
                A GNUTLS priority string describing the ciphers etc
                which may be used for the connection. In addition
                the string may be one of SSLv3, or TLSv1 to use the
                appropriate general settings for
                negotiating a connection of the specified
                type.
              
        </dd>
        <dt>GSTLSRemoteHosts</dt>
        <dd>
          
                A comma delimited list of host names to be allowed
                when verifying the certificate of the host we are
                connecting to. <br/> If this is not
                specified, all the names provided by NSHost
                are used.
              
        </dd>
        <dt>GSTLSRevokeFile</dt>
        <dd>
          
                The full path of a file containing certificate
                revocation information for certificates
                issued by our trusted authorites but no longer
                valid.
              
        </dd>
        <dt>GSTLSServerName</dt>
        <dd>
          
                By default the TLS layer when making an HTTPS
                request sets the &apos;Server Name Indication&apos; (SNI)
                to be the name of the host in the URL that is being
                fetched. <br/> This option allows the SNI to
                be set for other connections and permits overriding
                of the default behavior for HTTPS requests. Setting
                the value of GSTLSServerName to an empty string
                will prevent the SNI from being sent in the TLS
                handshake (this is sometimes desirable to
                prevent information leakage; the SNI
                information is sent unencrypted). <br/>
                Some web servers require SNI in order to tell what
                hostname an HTTPS request is for and decide
                which certificate to present to the client.
              
        </dd>
        <dt>GSTLSVerify</dt>
        <dd>
          
                A boolean specifying whether we should require the
                remote end to supply a valid certificate in
                order to establish an encrypted connection.
              
        </dd>
      </dl>
      
          
    </div>
    <hr class="method-separator"/>
</div>
    <br />
    <a href="Base.html">Up</a>
    </body>
</html>
